<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8">
	<title>std.traits - Phobos documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- styles -->
	<link href="bootDoc/assets/css/bootstrap.css" rel="stylesheet">
	<style type="text/css">
		body {
		padding-top: 60px;
		padding-bottom: 40px;
		}
		.sidebar-nav {
		padding: 9px 0;
		}
	</style>
	<link href="bootDoc/assets/css/bootstrap-responsive.css" rel="stylesheet">
	<link href="bootDoc/bootdoc.css" rel="stylesheet">

	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- fav and touch icons -->
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="bootDoc/assets/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="bootDoc/assets/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="bootDoc/assets/ico/apple-touch-icon-57-precomposed.png">
	
	<!-- Introduce DDoc settings required by JavaScript -->
	<script type="text/javascript">
		var Title = 'std.traits';
		var SourceRepository = 'https://github.com/D-Programming-Language/phobos/tree/master';
		var PackageSeparator = '.';
	</script>
	
	<style type="text/css">
		.ddoc-icon-variable { background-image: url('bootDoc/ddoc-icons/var.png'); }
		.ddoc-icon-function { background-image: url('bootDoc/ddoc-icons/func.png'); }
		.ddoc-icon-property { background-image: url('bootDoc/ddoc-icons/property.png'); }
		.ddoc-icon-struct { background-image: url('bootDoc/ddoc-icons/struct.png'); }
		.ddoc-icon-class { background-image: url('bootDoc/ddoc-icons/class.png'); }
		.ddoc-icon-enum { background-image: url('bootDoc/ddoc-icons/enum.png'); }
		.ddoc-icon-template { background-image: url('bootDoc/ddoc-icons/template.png'); }
	</style>
	</head>

	<body>
	<!--
	JavaScript reaps the module list from this element.
	This is required for the MODULES macro to be reusable
	in a noscript element later.
	-->
	<ul id="module-list-source" class="hidden">
		
	<li class="sidebar-list-entry tree-leaf"><a href="index.html" title="index"><i class="icon-th"></i>index</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.curl.html" title="etc.c.curl"><i class="icon-th"></i>etc.c.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.sqlite3.html" title="etc.c.sqlite3"><i class="icon-th"></i>etc.c.sqlite3</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.zlib.html" title="etc.c.zlib"><i class="icon-th"></i>etc.c.zlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.algorithm.html" title="std.algorithm"><i class="icon-th"></i>std.algorithm</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.array.html" title="std.array"><i class="icon-th"></i>std.array</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.ascii.html" title="std.ascii"><i class="icon-th"></i>std.ascii</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.base64.html" title="std.base64"><i class="icon-th"></i>std.base64</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bigint.html" title="std.bigint"><i class="icon-th"></i>std.bigint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bitmanip.html" title="std.bitmanip"><i class="icon-th"></i>std.bitmanip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.fenv.html" title="std.c.fenv"><i class="icon-th"></i>std.c.fenv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.locale.html" title="std.c.locale"><i class="icon-th"></i>std.c.locale</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.math.html" title="std.c.math"><i class="icon-th"></i>std.c.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.process.html" title="std.c.process"><i class="icon-th"></i>std.c.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdarg.html" title="std.c.stdarg"><i class="icon-th"></i>std.c.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stddef.html" title="std.c.stddef"><i class="icon-th"></i>std.c.stddef</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdio.html" title="std.c.stdio"><i class="icon-th"></i>std.c.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdlib.html" title="std.c.stdlib"><i class="icon-th"></i>std.c.stdlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.string.html" title="std.c.string"><i class="icon-th"></i>std.c.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.time.html" title="std.c.time"><i class="icon-th"></i>std.c.time</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.wcharh.html" title="std.c.wcharh"><i class="icon-th"></i>std.c.wcharh</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.com.html" title="std.c.windows.com"><i class="icon-th"></i>std.c.windows.com</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.stat.html" title="std.c.windows.stat"><i class="icon-th"></i>std.c.windows.stat</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.windows.html" title="std.c.windows.windows"><i class="icon-th"></i>std.c.windows.windows</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.winsock.html" title="std.c.windows.winsock"><i class="icon-th"></i>std.c.windows.winsock</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.compiler.html" title="std.compiler"><i class="icon-th"></i>std.compiler</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.complex.html" title="std.complex"><i class="icon-th"></i>std.complex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.concurrency.html" title="std.concurrency"><i class="icon-th"></i>std.concurrency</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.container.html" title="std.container"><i class="icon-th"></i>std.container</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.conv.html" title="std.conv"><i class="icon-th"></i>std.conv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.cstream.html" title="std.cstream"><i class="icon-th"></i>std.cstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.csv.html" title="std.csv"><i class="icon-th"></i>std.csv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.datetime.html" title="std.datetime"><i class="icon-th"></i>std.datetime</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.demangle.html" title="std.demangle"><i class="icon-th"></i>std.demangle</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.encoding.html" title="std.encoding"><i class="icon-th"></i>std.encoding</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.exception.html" title="std.exception"><i class="icon-th"></i>std.exception</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.file.html" title="std.file"><i class="icon-th"></i>std.file</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.format.html" title="std.format"><i class="icon-th"></i>std.format</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.functional.html" title="std.functional"><i class="icon-th"></i>std.functional</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.getopt.html" title="std.getopt"><i class="icon-th"></i>std.getopt</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.json.html" title="std.json"><i class="icon-th"></i>std.json</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.math.html" title="std.math"><i class="icon-th"></i>std.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mathspecial.html" title="std.mathspecial"><i class="icon-th"></i>std.mathspecial</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.md5.html" title="std.md5"><i class="icon-th"></i>std.md5</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.metastrings.html" title="std.metastrings"><i class="icon-th"></i>std.metastrings</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mmfile.html" title="std.mmfile"><i class="icon-th"></i>std.mmfile</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.curl.html" title="std.net.curl"><i class="icon-th"></i>std.net.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.isemail.html" title="std.net.isemail"><i class="icon-th"></i>std.net.isemail</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.numeric.html" title="std.numeric"><i class="icon-th"></i>std.numeric</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.outbuffer.html" title="std.outbuffer"><i class="icon-th"></i>std.outbuffer</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.parallelism.html" title="std.parallelism"><i class="icon-th"></i>std.parallelism</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.path.html" title="std.path"><i class="icon-th"></i>std.path</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.process.html" title="std.process"><i class="icon-th"></i>std.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.random.html" title="std.random"><i class="icon-th"></i>std.random</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.range.html" title="std.range"><i class="icon-th"></i>std.range</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.regex.html" title="std.regex"><i class="icon-th"></i>std.regex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.signals.html" title="std.signals"><i class="icon-th"></i>std.signals</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socket.html" title="std.socket"><i class="icon-th"></i>std.socket</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socketstream.html" title="std.socketstream"><i class="icon-th"></i>std.socketstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdarg.html" title="std.stdarg"><i class="icon-th"></i>std.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdint.html" title="std.stdint"><i class="icon-th"></i>std.stdint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdio.html" title="std.stdio"><i class="icon-th"></i>std.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdiobase.html" title="std.stdiobase"><i class="icon-th"></i>std.stdiobase</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stream.html" title="std.stream"><i class="icon-th"></i>std.stream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.string.html" title="std.string"><i class="icon-th"></i>std.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.syserror.html" title="std.syserror"><i class="icon-th"></i>std.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.system.html" title="std.system"><i class="icon-th"></i>std.system</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.traits.html" title="std.traits"><i class="icon-th"></i>std.traits</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typecons.html" title="std.typecons"><i class="icon-th"></i>std.typecons</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typetuple.html" title="std.typetuple"><i class="icon-th"></i>std.typetuple</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uni.html" title="std.uni"><i class="icon-th"></i>std.uni</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uri.html" title="std.uri"><i class="icon-th"></i>std.uri</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.utf.html" title="std.utf"><i class="icon-th"></i>std.utf</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.variant.html" title="std.variant"><i class="icon-th"></i>std.variant</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.charset.html" title="std.windows.charset"><i class="icon-th"></i>std.windows.charset</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.iunknown.html" title="std.windows.iunknown"><i class="icon-th"></i>std.windows.iunknown</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.registry.html" title="std.windows.registry"><i class="icon-th"></i>std.windows.registry</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.syserror.html" title="std.windows.syserror"><i class="icon-th"></i>std.windows.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.xml.html" title="std.xml"><i class="icon-th"></i>std.xml</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zip.html" title="std.zip"><i class="icon-th"></i>std.zip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zlib.html" title="std.zlib"><i class="icon-th"></i>std.zlib</a></li>
	</ul>
	
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container-fluid">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="index.html">Phobos</a>
				<div class="nav-collapse">
					<ul class="nav">
						<li class="active"><a href="index.html">Reference</a></li>
					</ul>
					
					<form id="gotosymbol" class="navbar-search pull-left hidden">
						<input type="text" class="search-query" placeholder="Go to symbol in std.traits" data-provide="typeahead" data-items="4">
					</form>
					
					<p class="navbar-text pull-right"><a href="https://github.com/D-Programming-Language/phobos">Github Page</a></p>
				</div><!--/.nav-collapse -->
			</div>
		</div>
	</div>

	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span2">
				<div class="well sidebar-nav">
				<ul class="nav nav-list">
					<li id="module-list" class="nav-header sidebar-list-entry">Modules<li>
					<noscript>
						
	<li class="sidebar-list-entry tree-leaf"><a href="index.html" title="index"><i class="icon-th"></i>index</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.curl.html" title="etc.c.curl"><i class="icon-th"></i>etc.c.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.sqlite3.html" title="etc.c.sqlite3"><i class="icon-th"></i>etc.c.sqlite3</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.zlib.html" title="etc.c.zlib"><i class="icon-th"></i>etc.c.zlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.algorithm.html" title="std.algorithm"><i class="icon-th"></i>std.algorithm</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.array.html" title="std.array"><i class="icon-th"></i>std.array</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.ascii.html" title="std.ascii"><i class="icon-th"></i>std.ascii</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.base64.html" title="std.base64"><i class="icon-th"></i>std.base64</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bigint.html" title="std.bigint"><i class="icon-th"></i>std.bigint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bitmanip.html" title="std.bitmanip"><i class="icon-th"></i>std.bitmanip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.fenv.html" title="std.c.fenv"><i class="icon-th"></i>std.c.fenv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.locale.html" title="std.c.locale"><i class="icon-th"></i>std.c.locale</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.math.html" title="std.c.math"><i class="icon-th"></i>std.c.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.process.html" title="std.c.process"><i class="icon-th"></i>std.c.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdarg.html" title="std.c.stdarg"><i class="icon-th"></i>std.c.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stddef.html" title="std.c.stddef"><i class="icon-th"></i>std.c.stddef</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdio.html" title="std.c.stdio"><i class="icon-th"></i>std.c.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdlib.html" title="std.c.stdlib"><i class="icon-th"></i>std.c.stdlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.string.html" title="std.c.string"><i class="icon-th"></i>std.c.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.time.html" title="std.c.time"><i class="icon-th"></i>std.c.time</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.wcharh.html" title="std.c.wcharh"><i class="icon-th"></i>std.c.wcharh</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.com.html" title="std.c.windows.com"><i class="icon-th"></i>std.c.windows.com</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.stat.html" title="std.c.windows.stat"><i class="icon-th"></i>std.c.windows.stat</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.windows.html" title="std.c.windows.windows"><i class="icon-th"></i>std.c.windows.windows</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.winsock.html" title="std.c.windows.winsock"><i class="icon-th"></i>std.c.windows.winsock</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.compiler.html" title="std.compiler"><i class="icon-th"></i>std.compiler</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.complex.html" title="std.complex"><i class="icon-th"></i>std.complex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.concurrency.html" title="std.concurrency"><i class="icon-th"></i>std.concurrency</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.container.html" title="std.container"><i class="icon-th"></i>std.container</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.conv.html" title="std.conv"><i class="icon-th"></i>std.conv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.cstream.html" title="std.cstream"><i class="icon-th"></i>std.cstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.csv.html" title="std.csv"><i class="icon-th"></i>std.csv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.datetime.html" title="std.datetime"><i class="icon-th"></i>std.datetime</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.demangle.html" title="std.demangle"><i class="icon-th"></i>std.demangle</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.encoding.html" title="std.encoding"><i class="icon-th"></i>std.encoding</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.exception.html" title="std.exception"><i class="icon-th"></i>std.exception</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.file.html" title="std.file"><i class="icon-th"></i>std.file</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.format.html" title="std.format"><i class="icon-th"></i>std.format</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.functional.html" title="std.functional"><i class="icon-th"></i>std.functional</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.getopt.html" title="std.getopt"><i class="icon-th"></i>std.getopt</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.json.html" title="std.json"><i class="icon-th"></i>std.json</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.math.html" title="std.math"><i class="icon-th"></i>std.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mathspecial.html" title="std.mathspecial"><i class="icon-th"></i>std.mathspecial</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.md5.html" title="std.md5"><i class="icon-th"></i>std.md5</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.metastrings.html" title="std.metastrings"><i class="icon-th"></i>std.metastrings</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mmfile.html" title="std.mmfile"><i class="icon-th"></i>std.mmfile</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.curl.html" title="std.net.curl"><i class="icon-th"></i>std.net.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.isemail.html" title="std.net.isemail"><i class="icon-th"></i>std.net.isemail</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.numeric.html" title="std.numeric"><i class="icon-th"></i>std.numeric</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.outbuffer.html" title="std.outbuffer"><i class="icon-th"></i>std.outbuffer</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.parallelism.html" title="std.parallelism"><i class="icon-th"></i>std.parallelism</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.path.html" title="std.path"><i class="icon-th"></i>std.path</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.process.html" title="std.process"><i class="icon-th"></i>std.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.random.html" title="std.random"><i class="icon-th"></i>std.random</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.range.html" title="std.range"><i class="icon-th"></i>std.range</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.regex.html" title="std.regex"><i class="icon-th"></i>std.regex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.signals.html" title="std.signals"><i class="icon-th"></i>std.signals</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socket.html" title="std.socket"><i class="icon-th"></i>std.socket</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socketstream.html" title="std.socketstream"><i class="icon-th"></i>std.socketstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdarg.html" title="std.stdarg"><i class="icon-th"></i>std.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdint.html" title="std.stdint"><i class="icon-th"></i>std.stdint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdio.html" title="std.stdio"><i class="icon-th"></i>std.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdiobase.html" title="std.stdiobase"><i class="icon-th"></i>std.stdiobase</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stream.html" title="std.stream"><i class="icon-th"></i>std.stream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.string.html" title="std.string"><i class="icon-th"></i>std.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.syserror.html" title="std.syserror"><i class="icon-th"></i>std.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.system.html" title="std.system"><i class="icon-th"></i>std.system</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.traits.html" title="std.traits"><i class="icon-th"></i>std.traits</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typecons.html" title="std.typecons"><i class="icon-th"></i>std.typecons</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typetuple.html" title="std.typetuple"><i class="icon-th"></i>std.typetuple</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uni.html" title="std.uni"><i class="icon-th"></i>std.uni</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uri.html" title="std.uri"><i class="icon-th"></i>std.uri</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.utf.html" title="std.utf"><i class="icon-th"></i>std.utf</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.variant.html" title="std.variant"><i class="icon-th"></i>std.variant</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.charset.html" title="std.windows.charset"><i class="icon-th"></i>std.windows.charset</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.iunknown.html" title="std.windows.iunknown"><i class="icon-th"></i>std.windows.iunknown</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.registry.html" title="std.windows.registry"><i class="icon-th"></i>std.windows.registry</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.syserror.html" title="std.windows.syserror"><i class="icon-th"></i>std.windows.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.xml.html" title="std.xml"><i class="icon-th"></i>std.xml</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zip.html" title="std.zip"><i class="icon-th"></i>std.zip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zlib.html" title="std.zlib"><i class="icon-th"></i>std.zlib</a></li>
					</noscript>
					<li id="symbol-list" class="nav-header sidebar-list-entry hidden">std.traits</li>
				</ul>
				</div><!--/.well -->
			</div><!--/span-->
			
			<div class="span10">
				<div class="row-fluid">
					<div class="span11">
						<ul id="module-breadcrumb" class="breadcrumb">
							<noscript><h1>std.traits</h1></noscript>
						</ul>
						
					</div>
					<div class="span1 offset11">
						<a href="index.html"><img src="dlogo-small.png" alt="The D Programming Language"/></a>
					</div>
				</div>
				<div id="declaration-list">
					<!-- Generated by Ddoc from phobos\std\traits.d -->
<dl><p>Templates with which to extract information about types and symbols at
 compile time.
</p>

<dt>License</dt><dd><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</dd>
<dt>Authors</dt><dd><a href="http://digitalmars.com">Walter Bright</a>,
            Tomasz Stachowiak (<span class="inlinecode">isExpressionTuple</span>),
            <a href="http://erdani.org">Andrei Alexandrescu</a>,
            Shin Fujishiro,
            <a href="http://octarineparrot.com">Robert Clipsham</a>,
            <a href="http://klickverbot.at">David Nadlinger</a>,
            Kenji Hara
</dd>
<dt>Source:</dt><dd>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/traits.d">std/traits.d</a></dd>
</dl>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Demangle">&nbsp;</span><a class="symbol-link" href="#Demangle">Demangle</a>(T);
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="defaultInit">&nbsp;</span><a class="symbol-link" href="#defaultInit">defaultInit</a>(T)</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="packageName">&nbsp;</span><a class="symbol-link" href="#packageName">packageName</a>(alias T)</h3></div>
<div class="declaration-content"><dl><p>Get the full package name for the given symbol.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits;
 <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>packageName</u>!(<u>packageName</u>) == <span class="d_string">"std"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="moduleName">&nbsp;</span><a class="symbol-link" href="#moduleName">moduleName</a>(alias T)</h3></div>
<div class="declaration-content"><dl><p>Get the module name (including package) for the given symbol.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits;
 <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>moduleName</u>!(<u>moduleName</u>) == <span class="d_string">"std.traits"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="fullyQualifiedName">&nbsp;</span><a class="symbol-link" href="#fullyQualifiedName">fullyQualifiedName</a>(alias T)</h3></div>
<div class="declaration-content"><dl><p>Get the fully qualified name of a symbol.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits;
 <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>fullyQualifiedName</u>!(<u>fullyQualifiedName</u>) == <span class="d_string">"std.traits.fullyQualifiedName"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="ReturnType">&nbsp;</span><a class="symbol-link" href="#ReturnType">ReturnType</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Get the type of the return value from a function,
 a pointer to function, a delegate, a struct
 with an opCall, a pointer to a struct with an opCall,
 or a class with an opCall.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits;
 <span class="d_keyword">int</span> foo();
 <u>ReturnType</u>!(foo) x;   <span class="d_comment">// x is declared as int
</span>
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="ParameterTypeTuple">&nbsp;</span><a class="symbol-link" href="#ParameterTypeTuple">ParameterTypeTuple</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Get, as a tuple, the types of the parameters to a function, a pointer
to function, a delegate, a struct with an <span class="inlinecode">opCall</span>, a pointer to a
struct with an <span class="inlinecode">opCall</span>, or a class with an <span class="inlinecode">opCall</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">import</span> std.traits;
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>);
<span class="d_keyword">void</span> bar(<u>ParameterTypeTuple</u>!(foo));      <span class="d_comment">// declares void bar(int, long);
</span>
<span class="d_keyword">void</span> abc(<u>ParameterTypeTuple</u>!(foo)[1]);   <span class="d_comment">// declares void abc(long);
</span>
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="arity">&nbsp;</span><a class="symbol-link" href="#arity">arity</a>(alias func) if (isCallable!(func) &amp;&amp; variadicFunctionStyle!(func) == Variadic.no)</h3></div>
<div class="declaration-content"><dl><p>Returns the number of arguments of function <span class="inlinecode">func</span>.
<span class="symbol-target" id="arity">&nbsp;</span><a class="symbol-link" href="#arity">arity</a> is undefined for variadic functions.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">void</span> foo(){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>arity</u>!foo==0);
<span class="d_keyword">void</span> bar(<span class="d_keyword">uint</span>){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>arity</u>!bar==1);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="ParameterStorageClass">&nbsp;</span><a class="symbol-link" href="#ParameterStorageClass">ParameterStorageClass</a>;
<br>template <span class="symbol-target" id="ParameterStorageClassTuple">&nbsp;</span><a class="symbol-link" href="#ParameterStorageClassTuple">ParameterStorageClassTuple</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Returns a tuple consisting of the storage classes of the parameters of a
function <span class="inlinecode">func</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">alias</span> <u>ParameterStorageClass</u> STC; <span class="d_comment">// shorten the enum name
</span>

<span class="d_keyword">void</span> func(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> ctx, <span class="d_keyword">out</span> <span class="d_keyword">real</span> result, <span class="d_keyword">real</span> param)
{
}
<span class="d_keyword">alias</span> ParameterStorageClassTuple!(func) pstc;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc.length == 3); <span class="d_comment">// three parameters
</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[0] == STC.ref_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[1] == STC.out_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[2] == STC.none);
</pre>
</dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="none">&nbsp;</span><a class="symbol-link" href="#none">none</a><br><span class="symbol-target" id="scope_">&nbsp;</span><a class="symbol-link" href="#scope_">scope_</a><br><span class="symbol-target" id="out_">&nbsp;</span><a class="symbol-link" href="#out_">out_</a><br><span class="symbol-target" id="ref_">&nbsp;</span><a class="symbol-link" href="#ref_">ref_</a><br><span class="symbol-target" id="lazy_">&nbsp;</span><a class="symbol-link" href="#lazy_">lazy_</a></h3></div>
<div class="declaration-content"><dl><p>These flags can be bitwise OR-ed together to represent complex storage
 class.
     
 ditto</p>

</dl>
</div>
</div>

</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="FunctionAttribute">&nbsp;</span><a class="symbol-link" href="#FunctionAttribute">FunctionAttribute</a>;
<br>template <span class="symbol-target" id="functionAttributes">&nbsp;</span><a class="symbol-link" href="#functionAttributes">functionAttributes</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Returns the attributes attached to a function <span class="inlinecode">func</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">alias</span> <u>FunctionAttribute</u> FA; <span class="d_comment">// shorten the enum name
</span>

<span class="d_keyword">real</span> func(<span class="d_keyword">real</span> x) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @safe
{
    <span class="d_keyword">return</span> x;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(functionAttributes!(func) &amp; FA.pure_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(functionAttributes!(func) &amp; FA.safe);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!(functionAttributes!(func) &amp; FA.trusted)); <span class="d_comment">// not @trusted
</span>
</pre>
</dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="none">&nbsp;</span><a class="symbol-link" href="#none">none</a><br><span class="symbol-target" id="pure_">&nbsp;</span><a class="symbol-link" href="#pure_">pure_</a><br><span class="symbol-target" id="nothrow_">&nbsp;</span><a class="symbol-link" href="#nothrow_">nothrow_</a><br><span class="symbol-target" id="ref_">&nbsp;</span><a class="symbol-link" href="#ref_">ref_</a><br><span class="symbol-target" id="property">&nbsp;</span><a class="symbol-link" href="#property">property</a><br><span class="symbol-target" id="trusted">&nbsp;</span><a class="symbol-link" href="#trusted">trusted</a><br><span class="symbol-target" id="safe">&nbsp;</span><a class="symbol-link" href="#safe">safe</a></h3></div>
<div class="declaration-content"><dl><p>These flags can be bitwise OR-ed together to represent complex attribute.
     
 ditto</p>

</dl>
</div>
</div>

</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isSafe">&nbsp;</span><a class="symbol-link" href="#isSafe">isSafe</a>(alias func) if (isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p><span class="inlinecode"><span class="d_keyword">true</span></span> if <span class="inlinecode">func</span> is <span class="inlinecode">@safe</span> or <span class="inlinecode">@trusted</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code">@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <u>isSafe</u>!add);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <u>isSafe</u>!sub);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<u>isSafe</u>!mul);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isUnsafe">&nbsp;</span><a class="symbol-link" href="#isUnsafe">isUnsafe</a>(alias func)</h3></div>
<div class="declaration-content"><dl><p><span class="inlinecode"><span class="d_keyword">true</span></span> if <span class="inlinecode">func</span> is <span class="inlinecode">@system</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code">@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<u>isUnsafe</u>!add);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<u>isUnsafe</u>!sub);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <u>isUnsafe</u>!mul);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="areAllSafe">&nbsp;</span><a class="symbol-link" href="#areAllSafe">areAllSafe</a>(funcs...) if (funcs.length &gt; 0)</h3></div>
<div class="declaration-content"><dl><p><font color=red>Scheduled for deprecation in January 2013. It's badly named and provides
redundant functionality. It was also badly broken prior to 2.060 (bug# 8362), so
any code which uses it probably needs to be changed anyway. Please use
<span class="inlinecode">allSatisfy(isSafe, ...)</span> instead.</font>
</p>

<p><span class="inlinecode"><span class="d_keyword">true</span></span> all functions are <span class="inlinecode">isSafe</span>.

</p>
<dt>Example:</dt><dd>
<pre class="d_code">@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <u>areAllSafe</u>!(add, add));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <u>areAllSafe</u>!(add, sub));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<u>areAllSafe</u>!(sub, mul));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="functionLinkage">&nbsp;</span><a class="symbol-link" href="#functionLinkage">functionLinkage</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Returns the calling convention of function as a string.
</p>

<dt>Example:</dt><dd>
<pre class="d_code">string a = <u>functionLinkage</u>!(writeln!(string, <span class="d_keyword">int</span>));
<span class="d_keyword">assert</span>(a == <span class="d_string">"D"</span>); <span class="d_comment">// extern(D)
</span>

<span class="d_keyword">auto</span> fp = &amp;printf;
string b = <u>functionLinkage</u>!(fp);
<span class="d_keyword">assert</span>(b == <span class="d_string">"C"</span>); <span class="d_comment">// extern(C)
</span>
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>enum <span class="symbol-target" id="Variadic">&nbsp;</span><a class="symbol-link" href="#Variadic">Variadic</a>;
<br>template <span class="symbol-target" id="variadicFunctionStyle">&nbsp;</span><a class="symbol-link" href="#variadicFunctionStyle">variadicFunctionStyle</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Determines what kind of variadic parameters function has.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">void</span> func() {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(variadicFunctionStyle!(func) == <u>Variadic</u>.no);

<span class="d_keyword">extern</span>(C) <span class="d_keyword">int</span> printf(<span class="d_keyword">in</span> <span class="d_keyword">char</span>*, ...);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(variadicFunctionStyle!(printf) == <u>Variadic</u>.c);
</pre>
</dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="no">&nbsp;</span><a class="symbol-link" href="#no">no</a></h3></div>
<div class="declaration-content"><dl><p>Function is not variadic.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="c">&nbsp;</span><a class="symbol-link" href="#c">c</a></h3></div>
<div class="declaration-content"><dl><p>Function is a C-style variadic function.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="d">&nbsp;</span><a class="symbol-link" href="#d">d</a></h3></div>
<div class="declaration-content"><dl><p>Function is a D-style variadic function, which uses
 _argptr and _arguments.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3><span class="symbol-target" id="typesafe">&nbsp;</span><a class="symbol-link" href="#typesafe">typesafe</a></h3></div>
<div class="declaration-content"><dl><p>Function is a <span class="symbol-target" id="typesafe">&nbsp;</span><a class="symbol-link" href="#typesafe">typesafe</a> variadic function.</p>

</dl>
</div>
</div>

</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="FunctionTypeOf">&nbsp;</span><a class="symbol-link" href="#FunctionTypeOf">FunctionTypeOf</a>(func...) if (func.length == 1 &amp;&amp; isCallable!(func))</h3></div>
<div class="declaration-content"><dl><p>Get the function type from a callable object <span class="inlinecode">func</span>.
</p>

<p>Using builtin <span class="inlinecode">typeof</span> on a property function yields the types of the
property value, not of the property function itself.  Still,
<span class="inlinecode"><span class="symbol-target" id="FunctionTypeOf">&nbsp;</span><a class="symbol-link" href="#FunctionTypeOf">FunctionTypeOf</a></span> is able to obtain function types of properties.
<pre class="d_code"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> value() @property;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( <span class="d_keyword">typeof</span>(C.value) == <span class="d_keyword">int</span> ));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( <u>FunctionTypeOf</u>!(C.value) == <span class="d_keyword">function</span> ));
</pre>

</p>
<dt>Note:</dt><dd>
Do not confuse function types with function pointer types; function types are
usually used for compile-time reflection purposes.</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="SetFunctionAttributes">&nbsp;</span><a class="symbol-link" href="#SetFunctionAttributes">SetFunctionAttributes</a>(T,string linkage,uint attrs) if (isFunctionPointer!(T) || isDelegate!(T))<br>template <span class="symbol-target" id="SetFunctionAttributes">&nbsp;</span><a class="symbol-link" href="#SetFunctionAttributes">SetFunctionAttributes</a>(T,string linkage,uint attrs) if (is(T == function))</h3></div>
<div class="declaration-content"><dl><p>Constructs a new function or delegate type with the same basic signature
 as the given one, but different attributes (including linkage).
</p>

<p>This is especially useful for adding/removing attributes from/to types in
 generic code, where the actual type name cannot be spelt out.

</p>
<dt>Parameters</dt><dd><table class="table table-condensed table-bordered"><tr><td>T</td>
<td>The base type.</td>
</tr>
<tr><td>linkage</td>
<td>The desired linkage of the result type.</td>
</tr>
<tr><td>attrs</td>
<td>The desired <a href="#FunctionAttribute"><span class="inlinecode">FunctionAttribute</span></a>s of the result type.</td>
</tr>
</table></dd>
<dt>Examples</dt><dd><pre class="d_code"> <span class="d_keyword">template</span> ExternC(T)
     <span class="d_keyword">if</span> (isFunctionPointer!T || isDelegate!T || <span class="d_keyword">is</span>(T == <span class="d_keyword">function</span>))
 {
     <span class="d_keyword">alias</span> <u>SetFunctionAttributes</u>!(T, <span class="d_string">"C"</span>, functionAttributes!T) ExternC;
 }
</pre>

<pre class="d_code"> <span class="d_keyword">auto</span> assumePure(T)(T t)
     <span class="d_keyword">if</span> (isFunctionPointer!T || isDelegate!T)
 {
     <span class="d_keyword">enum</span> attrs = functionAttributes!T | FunctionAttribute.pure_;
     <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<u>SetFunctionAttributes</u>!(T, functionLinkage!T, attrs)) t;
 }
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="FieldTypeTuple">&nbsp;</span><a class="symbol-link" href="#FieldTypeTuple">FieldTypeTuple</a>(S)</h3></div>
<div class="declaration-content"><dl><p>Get the types of the fields of a struct or class.
 This consists of the fields that take up memory space,
 excluding the hidden fields like the virtual function
 table pointer.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="RepresentationTypeTuple">&nbsp;</span><a class="symbol-link" href="#RepresentationTypeTuple">RepresentationTypeTuple</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Get the primitive types of the fields of a struct or class, in
topological order.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; <span class="d_keyword">float</span> b; }
<span class="d_keyword">struct</span> S2 { <span class="d_keyword">char</span>[] a; <span class="d_keyword">union</span> { S1 b; S1 * c; } }
<span class="d_keyword">alias</span> <u>RepresentationTypeTuple</u>!(S2) R;
<span class="d_keyword">assert</span>(R.length == 4
    &amp;&amp; <span class="d_keyword">is</span>(R[0] == <span class="d_keyword">char</span>[]) &amp;&amp; <span class="d_keyword">is</span>(R[1] == <span class="d_keyword">int</span>)
    &amp;&amp; <span class="d_keyword">is</span>(R[2] == <span class="d_keyword">float</span>) &amp;&amp; <span class="d_keyword">is</span>(R[3] == S1*));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasAliasing">&nbsp;</span><a class="symbol-link" href="#hasAliasing">hasAliasing</a>(T...)</h3></div>
<div class="declaration-content"><dl><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if <span class="inlinecode">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="inlinecode">U*</span> and <span class="inlinecode">U</span>
is not immutable;</li> <li>an array <span class="inlinecode">U[]</span> and <span class="inlinecode">U</span> is not
immutable;</li> <li>a reference to a class or interface type <span class="inlinecode">C</span> and <span class="inlinecode">C</span> is
not immutable.</li> <li>an associative array that is not immutable.</li>
<li>a delegate.</li></ol></p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasIndirections">&nbsp;</span><a class="symbol-link" href="#hasIndirections">hasIndirections</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if <span class="inlinecode">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="inlinecode">U*</span>;</li> <li>an
array <span class="inlinecode">U[]</span>;</li> <li>a reference to a class type <span class="inlinecode">C</span>.</li>
<li>an associative array.</li> <li>a delegate.</li></ol></p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasUnsharedAliasing">&nbsp;</span><a class="symbol-link" href="#hasUnsharedAliasing">hasUnsharedAliasing</a>(T...)</h3></div>
<div class="declaration-content"><dl><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if <span class="inlinecode">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="inlinecode">U*</span> and <span class="inlinecode">U</span>
is not immutable or shared;</li> <li>an array <span class="inlinecode">U[]</span> and <span class="inlinecode">U</span> is not
immutable or shared;</li> <li>a reference to a class type <span class="inlinecode">C</span> and
<span class="inlinecode">C</span> is not immutable or shared.</li> <li>an associative array that is not
immutable or shared.</li> <li>a delegate that is not shared.</li></ol></p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasElaborateCopyConstructor">&nbsp;</span><a class="symbol-link" href="#hasElaborateCopyConstructor">hasElaborateCopyConstructor</a>(S)</h3></div>
<div class="declaration-content"><dl><p>True if <span class="inlinecode">S</span> or any type embedded directly in the representation of <span class="inlinecode">S</span>
 defines an elaborate copy constructor. Elaborate copy constructors are
 introduced by defining <span class="inlinecode">this(this)</span> for a <span class="inlinecode">struct</span>. (Non-struct types
 never have elaborate copy constructors.)</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasElaborateAssign">&nbsp;</span><a class="symbol-link" href="#hasElaborateAssign">hasElaborateAssign</a>(S)</h3></div>
<div class="declaration-content"><dl><p>True if <span class="inlinecode">S</span> or any type directly embedded in the representation of <span class="inlinecode">S</span>
   defines an elaborate assignmentq. Elaborate assignments are introduced by
   defining <span class="inlinecode">opAssign(typeof(this))</span> or <span class="inlinecode">opAssign(ref typeof(this))</span>
   for a <span class="inlinecode">struct</span>. (Non-struct types never have elaborate assignments.)</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasElaborateDestructor">&nbsp;</span><a class="symbol-link" href="#hasElaborateDestructor">hasElaborateDestructor</a>(S)</h3></div>
<div class="declaration-content"><dl><p>True if <span class="inlinecode">S</span> or any type directly embedded in the representation
   of <span class="inlinecode">S</span> defines an elaborate destructor. Elaborate destructors
   are introduced by defining <span class="inlinecode">~this()</span> for a <span class="inlinecode">  struct</span>. (Non-struct types never have elaborate destructors, even
   though classes may define <span class="inlinecode">~this()</span>.)</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="hasMember">&nbsp;</span><a class="symbol-link" href="#hasMember">hasMember</a>(T,string name)</h3></div>
<div class="declaration-content"><dl><p>Yields <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if <span class="inlinecode">T</span> is an aggregate that defines
   a symbol called <span class="inlinecode">name</span>.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="EnumMembers">&nbsp;</span><a class="symbol-link" href="#EnumMembers">EnumMembers</a>(E) if (is(E == enum))</h3></div>
<div class="declaration-content"><dl><p>Retrieves the members of an enumerated type <span class="inlinecode">enum E</span>.
</p>

<dt>Parameters</dt><dd><table class="table table-condensed table-bordered"><tr><td>E</td>
<td>An enumerated type. <span class="inlinecode">E</span> may have duplicated values.</td>
</tr>
</table></dd>
<dt>Returns</dt><dd>Static tuple composed of the members of the enumerated type <span class="inlinecode">E</span>.
 The members are arranged in the same order as declared in <span class="inlinecode">E</span>.

</dd>
<dt>Note:</dt><dd>
Returned values are strictly typed with <span class="inlinecode">E</span>. Thus, the following code
 does not work without the explicit cast:
<pre class="d_code"><span class="d_keyword">enum</span> E : <span class="d_keyword">int</span> { a, b, c }
<span class="d_keyword">int</span>[] abc = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[]) [ <u>EnumMembers</u>!E ];
</pre>
 Cast is not necessary if the type of the variable is inferred. See the
 example below.

</dd>
<dt>Examples</dt><dd>Creating an array of enumerated values:
<pre class="d_code"><span class="d_keyword">enum</span> Sqrts : <span class="d_keyword">real</span>
{
    one   = 1,
    two   = 1.41421,
    three = 1.73205,
}
<span class="d_keyword">auto</span> sqrts = [ <u>EnumMembers</u>!Sqrts ];
<span class="d_keyword">assert</span>(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);
</pre>

 A generic function <span class="inlinecode">rank(v)</span> in the following example uses this
 template for finding a member <span class="inlinecode">e</span> in an enumerated type <span class="inlinecode">E</span>.
<pre class="d_code"><span class="d_comment">// Returns i if e is the i-th enumerator of E.
</span>
size_t rank(E)(E e)
    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(E == <span class="d_keyword">enum</span>))
{
    <span class="d_keyword">foreach</span> (i, member; <u>EnumMembers</u>!E)
    {
        <span class="d_keyword">if</span> (e == member)
            <span class="d_keyword">return</span> i;
    }
    <span class="d_keyword">assert</span>(0, <span class="d_string">"Not an enum member"</span>);
}

<span class="d_keyword">enum</span> Mode
{
    read  = 1,
    write = 2,
    map   = 4,
}
<span class="d_keyword">assert</span>(rank(Mode.read ) == 0);
<span class="d_keyword">assert</span>(rank(Mode.write) == 1);
<span class="d_keyword">assert</span>(rank(Mode.map  ) == 2);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="BaseTypeTuple">&nbsp;</span><a class="symbol-link" href="#BaseTypeTuple">BaseTypeTuple</a>(A)</h3></div>
<div class="declaration-content"><dl><p>Get a <b>TypeTuple</b> of the base class and base interfaces of
 this class or interface. <b><span class="symbol-target" id="BaseTypeTuple">&nbsp;</span><a class="symbol-link" href="#BaseTypeTuple">BaseTypeTuple</a>!(Object)</b> returns
 the empty type tuple.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits, std.typetuple, std.stdio;
 <span class="d_keyword">interface</span> I { }
 <span class="d_keyword">class</span> A { }
 <span class="d_keyword">class</span> B : A, I { }

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">alias</span> <u>BaseTypeTuple</u>!(B) TL;
     writeln(<span class="d_keyword">typeid</span>(TL));        <span class="d_comment">// prints: (A,I)
</span>
 }
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="BaseClassesTuple">&nbsp;</span><a class="symbol-link" href="#BaseClassesTuple">BaseClassesTuple</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Get a <b>TypeTuple</b> of <i>all</i> base classes of this class,
 in decreasing order. Interfaces are not included. <b><span class="symbol-target" id="BaseClassesTuple">&nbsp;</span><a class="symbol-link" href="#BaseClassesTuple">BaseClassesTuple</a>!(Object)</b> yields the empty type tuple.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits, std.typetuple, std.stdio;
 <span class="d_keyword">interface</span> I { }
 <span class="d_keyword">class</span> A { }
 <span class="d_keyword">class</span> B : A, I { }
 <span class="d_keyword">class</span> C : B { }

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">alias</span> <u>BaseClassesTuple</u>!(C) TL;
     writeln(<span class="d_keyword">typeid</span>(TL));        <span class="d_comment">// prints: (B,A,Object)
</span>
 }
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="InterfacesTuple">&nbsp;</span><a class="symbol-link" href="#InterfacesTuple">InterfacesTuple</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Get a <b>TypeTuple</b> of <i>all</i> interfaces directly or
 indirectly inherited by this class or interface. Interfaces do not
 repeat if multiply implemented. <b><span class="symbol-target" id="InterfacesTuple">&nbsp;</span><a class="symbol-link" href="#InterfacesTuple">InterfacesTuple</a>!(Object)</b>
 yields the empty type tuple.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits, std.typetuple, std.stdio;
 <span class="d_keyword">interface</span> I1 { }
 <span class="d_keyword">interface</span> I2 { }
 <span class="d_keyword">class</span> A : I1, I2 { }
 <span class="d_keyword">class</span> B : A, I1 { }
 <span class="d_keyword">class</span> C : B { }

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">alias</span> <u>InterfacesTuple</u>!(C) TL;
     writeln(<span class="d_keyword">typeid</span>(TL));        <span class="d_comment">// prints: (I1, I2)
</span>
 }
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="TransitiveBaseTypeTuple">&nbsp;</span><a class="symbol-link" href="#TransitiveBaseTypeTuple">TransitiveBaseTypeTuple</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Get a <b>TypeTuple</b> of <i>all</i> base classes of <b>T</b>, in decreasing order, followed by <b>T</b>'s
 interfaces. <b><span class="symbol-target" id="TransitiveBaseTypeTuple">&nbsp;</span><a class="symbol-link" href="#TransitiveBaseTypeTuple">TransitiveBaseTypeTuple</a>!(Object)</b> yields the
 empty type tuple.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits, std.typetuple, std.stdio;
 <span class="d_keyword">interface</span> I { }
 <span class="d_keyword">class</span> A { }
 <span class="d_keyword">class</span> B : A, I { }
 <span class="d_keyword">class</span> C : B { }

 <span class="d_keyword">void</span> main()
 {
     <span class="d_keyword">alias</span> <u>TransitiveBaseTypeTuple</u>!(C) TL;
     writeln(<span class="d_keyword">typeid</span>(TL));        <span class="d_comment">// prints: (B,A,Object,I)
</span>
 }
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="MemberFunctionsTuple">&nbsp;</span><a class="symbol-link" href="#MemberFunctionsTuple">MemberFunctionsTuple</a>(C,string name) if (is(C == class) || is(C == interface))</h3></div>
<div class="declaration-content"><dl><p>Returns a tuple of non-static functions with the name <span class="inlinecode">name</span> declared in the
class or interface <span class="inlinecode">C</span>.  Covariant duplicates are shrunk into the most
derived one.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">interface</span> I { I foo(); }
<span class="d_keyword">class</span> B
{
    <span class="d_keyword">real</span> foo(<span class="d_keyword">real</span> v) { <span class="d_keyword">return</span> v; }
}
<span class="d_keyword">class</span> C : B, I
{
    <span class="d_keyword">override</span> C foo() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; } <span class="d_comment">// covariant overriding of I.foo()
</span>
}
<span class="d_keyword">alias</span> <u>MemberFunctionsTuple</u>!(C, <span class="d_string">"foo"</span>) foos;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(foos.length == 2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, foos[0], C.foo));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, foos[1], B.foo));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="CommonType">&nbsp;</span><a class="symbol-link" href="#CommonType">CommonType</a>(T...)</h3></div>
<div class="declaration-content"><dl><p>Get the type that all types can be implicitly converted to. Useful
e.g. in figuring out an array type from a bunch of initializing
values. Returns <b>void</b> if passed an empty list, or if the
types have no common type.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">alias</span> <u>CommonType</u>!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>, <span class="d_keyword">short</span>) X;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(X == <span class="d_keyword">long</span>));
<span class="d_keyword">alias</span> <u>CommonType</u>!(<span class="d_keyword">int</span>, <span class="d_keyword">char</span>[], <span class="d_keyword">short</span>) Y;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Y == <span class="d_keyword">void</span>));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="ImplicitConversionTargets">&nbsp;</span><a class="symbol-link" href="#ImplicitConversionTargets">ImplicitConversionTargets</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Returns a tuple with all possible target types of an implicit
 conversion of a value of type <b>T</b>.
</p>

<p>Important note:
<br><br>

 The possible targets are computed more conservatively than the D
 2.005 compiler does, eliminating all dangerous conversions. For
 example, <b><span class="symbol-target" id="ImplicitConversionTargets">&nbsp;</span><a class="symbol-link" href="#ImplicitConversionTargets">ImplicitConversionTargets</a>!(double)</b> does not
 include <b>float</b>.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isImplicitlyConvertible">&nbsp;</span><a class="symbol-link" href="#isImplicitlyConvertible">isImplicitlyConvertible</a>(From,To)</h3></div>
<div class="declaration-content"><dl><p>Is <span class="inlinecode">From</span> implicitly convertible to <span class="inlinecode">To</span>?</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isAssignable">&nbsp;</span><a class="symbol-link" href="#isAssignable">isAssignable</a>(Lhs,Rhs)</h3></div>
<div class="declaration-content"><dl><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> iff a value of type <span class="inlinecode">Rhs</span> can be assigned to a variable of
type <span class="inlinecode">Lhs</span>.
</p>

<dt>Examples</dt><dd><pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>isAssignable</u>!(<span class="d_keyword">long</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<u>isAssignable</u>!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <u>isAssignable</u>!(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[], string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<u>isAssignable</u>!(string, <span class="d_keyword">char</span>[]));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isCovariantWith">&nbsp;</span><a class="symbol-link" href="#isCovariantWith">isCovariantWith</a>(F,G) if (is(F == function) &amp;&amp; is(G == function))</h3></div>
<div class="declaration-content"><dl><p>Determines whether the function type <span class="inlinecode">F</span> is covariant with <span class="inlinecode">G</span>, i.e.,
functions of the type <span class="inlinecode">F</span> can override ones of the type <span class="inlinecode">G</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">interface</span> I { I clone(); }
<span class="d_keyword">interface</span> J { J clone(); }
<span class="d_keyword">class</span> C : I
{
    <span class="d_keyword">override</span> C clone()   <span class="d_comment">// covariant overriding of I.clone()
</span>
    {
        <span class="d_keyword">return</span> <span class="d_keyword">new</span> C;
    }
}

<span class="d_comment">// C.clone() can override I.clone(), indeed.
</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>isCovariantWith</u>!(<span class="d_keyword">typeof</span>(C.clone), <span class="d_keyword">typeof</span>(I.clone)));

<span class="d_comment">// C.clone() can't override J.clone(); the return type C is not implicitly
</span>
<span class="d_comment">// convertible to J.
</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<u>isCovariantWith</u>!(<span class="d_keyword">typeof</span>(C.clone), <span class="d_keyword">typeof</span>(J.clone)));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isBoolean">&nbsp;</span><a class="symbol-link" href="#isBoolean">isBoolean</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether we can treat T as a built-in boolean type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isIntegral">&nbsp;</span><a class="symbol-link" href="#isIntegral">isIntegral</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether we can treat T as a built-in integral type. Types <span class="inlinecode">bool</span>,
 <span class="inlinecode">char</span>, <span class="inlinecode">wchar</span>, and <span class="inlinecode">dchar</span> are not considered integral.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isFloatingPoint">&nbsp;</span><a class="symbol-link" href="#isFloatingPoint">isFloatingPoint</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether we can treat T as a built-in floating point type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isNumeric">&nbsp;</span><a class="symbol-link" href="#isNumeric">isNumeric</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether we can treat T as a built-in numeric type (integral or floating
point).</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isScalarType">&nbsp;</span><a class="symbol-link" href="#isScalarType">isScalarType</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether T is a scalar type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isBasicType">&nbsp;</span><a class="symbol-link" href="#isBasicType">isBasicType</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether T is a basic type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isUnsigned">&nbsp;</span><a class="symbol-link" href="#isUnsigned">isUnsigned</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether <span class="inlinecode">T</span> is a built-in unsigned numeric type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isSigned">&nbsp;</span><a class="symbol-link" href="#isSigned">isSigned</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether <span class="inlinecode">T</span> is a built-in signed numeric type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isSomeChar">&nbsp;</span><a class="symbol-link" href="#isSomeChar">isSomeChar</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether we can treat T as one of the built-in character types.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isSomeString">&nbsp;</span><a class="symbol-link" href="#isSomeString">isSomeString</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether we can treat T as one of the built-in string types.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isStaticArray">&nbsp;</span><a class="symbol-link" href="#isStaticArray">isStaticArray</a>(T : U[N],U,size_t N)</h3></div>
<div class="declaration-content"><dl><p>Detect whether type T is a static array.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isDynamicArray">&nbsp;</span><a class="symbol-link" href="#isDynamicArray">isDynamicArray</a>(T,U = void)</h3></div>
<div class="declaration-content"><dl><p>Detect whether type T is a dynamic array.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isArray">&nbsp;</span><a class="symbol-link" href="#isArray">isArray</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether type T is an array.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isAssociativeArray">&nbsp;</span><a class="symbol-link" href="#isAssociativeArray">isAssociativeArray</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether T is an associative array type</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isPointer">&nbsp;</span><a class="symbol-link" href="#isPointer">isPointer</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether type <span class="inlinecode">T</span> is a pointer.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="PointerTarget">&nbsp;</span><a class="symbol-link" href="#PointerTarget">PointerTarget</a>(T : T*)</h3></div>
<div class="declaration-content"><dl><p>Returns the target type of a pointer.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>alias <span class="symbol-target" id="pointerTarget">&nbsp;</span><a class="symbol-link" href="#pointerTarget">pointerTarget</a>;
</h3></div>
<div class="declaration-content"><dl><p><font color=red>Scheduled for deprecation. Please use <a href="#PointerTarget"><span class="inlinecode">PointerTarget</span></a> instead.</font></p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isAggregateType">&nbsp;</span><a class="symbol-link" href="#isAggregateType">isAggregateType</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Detect whether type <span class="inlinecode">T</span> is an aggregate type.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isIterable">&nbsp;</span><a class="symbol-link" href="#isIterable">isIterable</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if T can be iterated over using a <span class="inlinecode">foreach</span> loop with
 a single loop variable of automatically inferred type, regardless of how
 the <span class="inlinecode">foreach</span> loop is implemented.  This includes ranges, structs/classes
 that define <span class="inlinecode">opApply</span> with a single loop variable, and builtin dynamic,
 static and associative arrays.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isExpressionTuple">&nbsp;</span><a class="symbol-link" href="#isExpressionTuple">isExpressionTuple</a>(T...)</h3></div>
<div class="declaration-content"><dl><p>Tells whether the tuple T is an expression tuple.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isTypeTuple">&nbsp;</span><a class="symbol-link" href="#isTypeTuple">isTypeTuple</a>(T...)</h3></div>
<div class="declaration-content"><dl><p>Detect whether tuple <span class="inlinecode">T</span> is a type tuple.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isFunctionPointer">&nbsp;</span><a class="symbol-link" href="#isFunctionPointer">isFunctionPointer</a>(T...) if (T.length == 1)</h3></div>
<div class="declaration-content"><dl><p>Detect whether symbol or type <span class="inlinecode">T</span> is a function pointer.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isDelegate">&nbsp;</span><a class="symbol-link" href="#isDelegate">isDelegate</a>(T...) if (T.length == 1)</h3></div>
<div class="declaration-content"><dl><p>Detect whether <span class="inlinecode">T</span> is a delegate.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isSomeFunction">&nbsp;</span><a class="symbol-link" href="#isSomeFunction">isSomeFunction</a>(T...) if (T.length == 1)</h3></div>
<div class="declaration-content"><dl><p>Detect whether symbol or type <span class="inlinecode">T</span> is a function, a function pointer or a delegate.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isCallable">&nbsp;</span><a class="symbol-link" href="#isCallable">isCallable</a>(T...) if (T.length == 1)</h3></div>
<div class="declaration-content"><dl><p>Detect whether <span class="inlinecode">T</span> is a callable object, which can be called with the
function call operator <span class="inlinecode">(...)</span>.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="isAbstractFunction">&nbsp;</span><a class="symbol-link" href="#isAbstractFunction">isAbstractFunction</a>(method...) if (method.length == 1)</h3></div>
<div class="declaration-content"><dl><p>Exactly the same as the builtin traits:
<span class="inlinecode">__traits(isAbstractFunction, method)</span>.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="Unqual">&nbsp;</span><a class="symbol-link" href="#Unqual">Unqual</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Removes all qualifiers, if any, from type <span class="inlinecode">T</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>Unqual</u>!(<span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>Unqual</u>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>Unqual</u>!(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>Unqual</u>!(<span class="d_keyword">shared</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>Unqual</u>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span>)) == <span class="d_keyword">int</span>));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="ForeachType">&nbsp;</span><a class="symbol-link" href="#ForeachType">ForeachType</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Returns the inferred type of the loop variable when a variable of type T
is iterated over using a <span class="inlinecode">foreach</span> loop with a single loop variable and
automatically inferred return type.  Note that this may not be the same as
<span class="inlinecode">std.range.ElementType!(Range)</span> in the case of narrow strings, or if T
has both opApply and a range interface.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="OriginalType">&nbsp;</span><a class="symbol-link" href="#OriginalType">OriginalType</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Strips off all <span class="inlinecode">typedef</span>s (including <span class="inlinecode">enum</span> ones) from type <span class="inlinecode">T</span>.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">enum</span> E : <span class="d_keyword">int</span> { a }
<span class="d_keyword">typedef</span> E F;
<span class="d_keyword">typedef</span> <span class="d_keyword">const</span> F G;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>OriginalType</u>!G == <span class="d_keyword">const</span> <span class="d_keyword">int</span>));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="KeyType">&nbsp;</span><a class="symbol-link" href="#KeyType">KeyType</a>(V : V[K],K)</h3></div>
<div class="declaration-content"><dl><p>Get the Key type of an Associative Array.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits;
 <span class="d_keyword">alias</span> <span class="d_keyword">int</span>[string] Hash;
 <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>KeyType</u>!Hash == string));
 <u>KeyType</u>!Hash str = <span class="d_string">"string"</span>;   <span class="d_comment">// str is declared as string
</span>
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="ValueType">&nbsp;</span><a class="symbol-link" href="#ValueType">ValueType</a>(V : V[K],K)</h3></div>
<div class="declaration-content"><dl><p>Get the Value type of an Associative Array.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"> <span class="d_keyword">import</span> std.traits;
 <span class="d_keyword">alias</span> <span class="d_keyword">int</span>[string] Hash;
 <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<u>ValueType</u>!Hash == <span class="d_keyword">int</span>));
 <u>ValueType</u>!Hash num = 1;   <span class="d_comment">// num is declared as int
</span>
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="Unsigned">&nbsp;</span><a class="symbol-link" href="#Unsigned">Unsigned</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Returns the corresponding unsigned type for T. T must be a numeric
 integral type, otherwise a compile-time error occurs.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="Largest">&nbsp;</span><a class="symbol-link" href="#Largest">Largest</a>(T...) if (T.length &gt;= 1)</h3></div>
<div class="declaration-content"><dl><p>Returns the largest type, i.e. T such that T.sizeof is the largest.  If more
than one type is of the same size, the leftmost argument of these in will be
returned.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="Signed">&nbsp;</span><a class="symbol-link" href="#Signed">Signed</a>(T)</h3></div>
<div class="declaration-content"><dl><p>Returns the corresponding signed type for T. T must be a numeric integral type,
otherwise a compile-time error occurs.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>auto <span class="symbol-target" id="unsigned">&nbsp;</span><a class="symbol-link" href="#unsigned">unsigned</a>(T)(T <i>x</i>);
</h3></div>
<div class="declaration-content"><dl><p>Returns the corresponding <span class="symbol-target" id="unsigned">&nbsp;</span><a class="symbol-link" href="#unsigned">unsigned</a> value for <span class="inlinecode">x</span>, e.g. if <span class="inlinecode">x</span>
 has type <span class="inlinecode">int</span>, returns <span class="inlinecode">cast(uint) x</span>. The advantage
 compared to the cast is that you do not need to rewrite the cast if
 <span class="inlinecode">x</span> later changes type to e.g. <span class="inlinecode">long</span>.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="mostNegative">&nbsp;</span><a class="symbol-link" href="#mostNegative">mostNegative</a>(T) if (isNumeric!(T) || isSomeChar!(T))</h3></div>
<div class="declaration-content"><dl><p>Returns the most negative value of the numeric type T.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="mangledName">&nbsp;</span><a class="symbol-link" href="#mangledName">mangledName</a>(sth...) if (sth.length == 1)</h3></div>
<div class="declaration-content"><dl><p>Returns the mangled name of symbol or type <span class="inlinecode">sth</span>.
</p>

<p><span class="inlinecode"><span class="symbol-target" id="mangledName">&nbsp;</span><a class="symbol-link" href="#mangledName">mangledName</a></span> is the same as builtin <span class="inlinecode">.mangleof</span> property, except that
the correct names of property functions are obtained.
<pre class="d_code"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.traits : <u>mangledName</u>;

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> value() @property;
}
<span class="d_keyword">pragma</span>(msg, C.value.mangleof);      <span class="d_comment">// prints "i"
</span>
<span class="d_keyword">pragma</span>(msg, <u>mangledName</u>!(C.value)); <span class="d_comment">// prints "_D4test1C5valueMFNdZi"
</span>
</pre>
</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="Select">&nbsp;</span><a class="symbol-link" href="#Select">Select</a>(bool condition,T,F)</h3></div>
<div class="declaration-content"><dl><p>Aliases itself to <span class="inlinecode">T</span> if the boolean <span class="inlinecode">condition</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>
and to <span class="inlinecode">F</span> otherwise.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">alias</span> <u>Select</u>!(size_t.sizeof == 4, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Int;
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>A <span class="symbol-target" id="select">&nbsp;</span><a class="symbol-link" href="#select">select</a>(bool cond : true, A, B)(A <i>a</i>, lazy B <i>b</i>);
<br>B <span class="symbol-target" id="select">&nbsp;</span><a class="symbol-link" href="#select">select</a>(bool cond : false, A, B)(lazy A <i>a</i>, B <i>b</i>);
</h3></div>
<div class="declaration-content"><dl><p>If <span class="inlinecode">cond</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>, returns <span class="inlinecode">a</span> without evaluating <span class="inlinecode">b</span>. Otherwise, returns <span class="inlinecode">b</span> without evaluating <span class="inlinecode">a</span>.</p>

</dl>
</div>


				</div>
				
				<hr>
				
				<footer class="pull-left">
					<p>Page generated with <a href="https://github.com/JakobOvrum/bootDoc">bootDoc</a>.</p>
				</footer>
				
				<footer class="pull-right">
					<p>&copy; Copyright Digital Mars 2005 - 2009.
</p>
				</footer>
			</div>
		</div>
	</div><!--/.fluid-container-->

	<!-- Bootstrap javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="bootDoc/assets/js/jquery.min.js"></script>
	<script src="bootDoc/assets/js/bootstrap.min.js"></script>
	
	<!-- bootDoc javascript
	================================================== -->
	<script src="bootDoc/bootdoc.js"></script>
	
	</body>
</html>

