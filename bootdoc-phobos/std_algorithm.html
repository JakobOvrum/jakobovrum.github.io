<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8">
	<title>std.algorithm - Phobos documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- styles -->
	<link href="bootDoc/assets/css/bootstrap.css" rel="stylesheet">
	<style type="text/css">
		body {
		padding-top: 60px;
		padding-bottom: 40px;
		}
		.sidebar-nav {
		padding: 9px 0;
		}
	</style>
	<link href="bootDoc/assets/css/bootstrap-responsive.css" rel="stylesheet">
	<link href="bootDoc/bootdoc.css" rel="stylesheet">

	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- fav and touch icons -->
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="bootDoc/assets/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="bootDoc/assets/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="bootDoc/assets/ico/apple-touch-icon-57-precomposed.png">
	
	<!-- Introduce DDoc settings required by JavaScript -->
	<script type="text/javascript">
		var Title = 'std.algorithm';
		var SourceRepository = 'https://github.com/D-Programming-Language/phobos/tree/master';
		var Modules = [
			
	"index",
	"etc.c.curl",
	"etc.c.sqlite3",
	"etc.c.zlib",
	"std.algorithm",
	"std.array",
	"std.ascii",
	"std.base64",
	"std.bigint",
	"std.bind",
	"std.bitmanip",
	"std.c.fenv",
	"std.c.locale",
	"std.c.math",
	"std.c.process",
	"std.c.stdarg",
	"std.c.stddef",
	"std.c.stdio",
	"std.c.stdlib",
	"std.c.string",
	"std.c.time",
	"std.c.wcharh",
	"std.c.windows.com",
	"std.c.windows.stat",
	"std.c.windows.windows",
	"std.c.windows.winsock",
	"std.compiler",
	"std.complex",
	"std.concurrency",
	"std.container",
	"std.conv",
	"std.cpuid",
	"std.cstream",
	"std.csv",
	"std.datetime",
	"std.demangle",
	"std.encoding",
	"std.exception",
	"std.file",
	"std.format",
	"std.functional",
	"std.getopt",
	"std.json",
	"std.loader",
	"std.math",
	"std.mathspecial",
	"std.md5",
	"std.metastrings",
	"std.mmfile",
	"std.net.curl",
	"std.net.isemail",
	"std.numeric",
	"std.outbuffer",
	"std.parallelism",
	"std.path",
	"std.perf",
	"std.process",
	"std.random",
	"std.range",
	"std.regex",
	"std.regexp",
	"std.signals",
	"std.socket",
	"std.socketstream",
	"std.stdarg",
	"std.stdint",
	"std.stdio",
	"std.stdiobase",
	"std.stream",
	"std.string",
	"std.syserror",
	"std.system",
	"std.traits",
	"std.typecons",
	"std.typetuple",
	"std.uni",
	"std.uri",
	"std.utf",
	"std.variant",
	"std.windows.charset",
	"std.windows.iunknown",
	"std.windows.registry",
	"std.windows.syserror",
	"std.xml",
	"std.zip",
	"std.zlib",
		];
	</script>
	
	<style type="text/css">
		.ddoc-icon-variable { background-image: url('bootDoc/ddoc-icons/var.png'); }
		.ddoc-icon-function { background-image: url('bootDoc/ddoc-icons/func.png'); }
		.ddoc-icon-property { background-image: url('bootDoc/ddoc-icons/property.png'); }
		.ddoc-icon-struct { background-image: url('bootDoc/ddoc-icons/struct.png'); }
		.ddoc-icon-class { background-image: url('bootDoc/ddoc-icons/class.png'); }
		.ddoc-icon-enum { background-image: url('bootDoc/ddoc-icons/enum.png'); }
		.ddoc-icon-template { background-image: url('bootDoc/ddoc-icons/template.png'); }
	</style>
	</head>

	<body>
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container-fluid">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="index.html">Phobos</a>
				<div class="nav-collapse">
					<ul class="nav">
						<li class="active"><a href="index.html">Reference</a></li>
					</ul>
					
					<form id="gotosymbol" class="navbar-search pull-left hidden">
						<input type="text" class="search-query" placeholder="Goto symbol in std.algorithm" data-provide="typeahead" data-items="4">
					</form>
					
					<p class="navbar-text pull-right"><a href="https://github.com/D-Programming-Language/phobos">Github Page</a></p>
				</div><!--/.nav-collapse -->
			</div>
		</div>
	</div>

	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span2">
				<div class="well sidebar-nav">
				<ul class="nav nav-list">
					<li id="module-list" class="nav-header">Modules<li>
					<li id="symbol-list" class="nav-header hidden">std.algorithm</li>
				</ul>
				</div><!--/.well -->
			</div><!--/span-->
			
			<div class="span10">
				<div class="row-fluid">
					<div class="span11">
						<ul id="module-breadcrumb" class="breadcrumb">
							<noscript><h1>std.algorithm</h1></noscript>
						</ul>
						
					</div>
					<div class="span1 offset11">
						<a href="index.html"><img src="dlogo-small.png" alt="The D Programming Language"/></a>
					</div>
				</div>
				<div id="declaration-list">
					<!-- Generated by Ddoc from phobos\std\algorithm.d -->
<p><script type="text/javascript">inhibitQuickIndex = 1</script>
</p>

<p><table cellspacing=0 cellpadding=5 class=book><caption></caption><tr><th>Category</th> <th>Functions</th>
</tr>
<tr><td valign=top class="donthyphenate">Searching</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#balancedParens">balancedParens</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#boyerMooreFinder">boyerMooreFinder</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#canFind">canFind</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#count">count</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#countUntil">countUntil</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#endsWith">endsWith</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#commonPrefix">commonPrefix</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#find">find</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findAdjacent">findAdjacent</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findAmong">findAmong</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSkip">findSkip</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSplit">findSplit</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSplitAfter">findSplitAfter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSplitBefore">findSplitBefore</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#indexOf">indexOf</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#minCount">minCount</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#minPos">minPos</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#mismatch">mismatch</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#skipOver">skipOver</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#startsWith">startsWith</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#until">until</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Comparison</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#cmp">cmp</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#equal">equal</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#levenshteinDistance">levenshteinDistance</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#levenshteinDistanceAndPath">levenshteinDistanceAndPath</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#max">max</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#min">min</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#mismatch">mismatch</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Iteration</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#filter">filter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#filterBidirectional">filterBidirectional</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#group">group</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#joiner">joiner</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#map">map</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#reduce">reduce</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#splitter">splitter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#uniq">uniq</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Sorting</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#completeSort">completeSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#isPartitioned">isPartitioned</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#isSorted">isSorted</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#makeIndex">makeIndex</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#partialSort">partialSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#partition">partition</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#partition3">partition3</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#schwartzSort">schwartzSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#sort">sort</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#topN">topN</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#topNCopy">topNCopy</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Set&nbsp;operations</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#largestPartialIntersection">largestPartialIntersection</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#largestPartialIntersectionWeighted">largestPartialIntersectionWeighted</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#nWayUnion">nWayUnion</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setDifference">setDifference</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setIntersection">setIntersection</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setSymmetricDifference">setSymmetricDifference</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setUnion">setUnion</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Mutation</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#bringToFront">bringToFront</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#copy">copy</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#fill">fill</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#initializeAll">initializeAll</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#move">move</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#moveAll">moveAll</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#moveSome">moveSome</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#remove">remove</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#reverse">reverse</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#swap">swap</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#swapRanges">swapRanges</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#uninitializedFill">uninitializedFill</a>&nbsp;</font> </td></tr>
</table>
<br><br>

Implements algorithms oriented mainly towards processing of
sequences. Some functions are semantic equivalents or supersets of
those found in the <span class="inlinecode">&lt;algorithm&gt;</span> header in <a href="http://sgi.com/tech/stl/">Alexander Stepanov's Standard Template Library</a> for
C++.
<br><br>

Many functions in this module are parameterized with a function or a
<a href="../glossary.html#predicate">predicate</a>. The predicate may be passed either as a
function name, a delegate name, a <a href="../glossary.html#functor">functor</a> name, or a
compile-time string. The string may consist of <b>any</b> legal D
expression that uses the symbol <span class="inlinecode">a</span> (for unary functions) or the
symbols <span class="inlinecode">a</span> and <span class="inlinecode">b</span> (for binary functions). These names will NOT
interfere with other homonym symbols in user code because they are
evaluated in a different context. The default for all binary
comparison predicates is <span class="inlinecode">"a == b"</span> for unordered operations and
<span class="inlinecode">"a &lt; b"</span> for ordered operations.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = ...;
<span class="d_keyword">static</span> <span class="d_keyword">bool</span> greater(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
{
    <span class="d_keyword">return</span> a &gt; b;
}
sort!(greater)(a);  <span class="d_comment">// predicate as alias
</span>
sort!(<span class="d_string">"a &gt; b"</span>)(a);  <span class="d_comment">// predicate as string
</span>
                    <span class="d_comment">// (no ambiguity with array name)
</span>
sort(a);            <span class="d_comment">// no predicate, "a &lt; b" is implicit
</span>
</pre>

<table cellspacing=0 cellpadding=5 class=book><caption>Cheat Sheet</caption><tr><th>Function Name</th> <th>Description</th>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Searching
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#balancedParens"><span class="inlinecode">balancedParens</span></a></td> <td valign=top><span class="inlinecode">balancedParens("((1 + 1) / 2)")</span> returns <span class="inlinecode"><span class="d_keyword">true</span></span> because the string
has balanced parentheses.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#boyerMooreFinder"><span class="inlinecode">boyerMooreFinder</span></a></td> <td valign=top><span class="inlinecode">find("hello
world", boyerMooreFinder("or"))</span> returns <span class="inlinecode">"orld"</span> using the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Boyer-Moore algorithm">Boyer-Moore algorithm</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#canFind"><span class="inlinecode">canFind</span></a></td> <td valign=top><span class="inlinecode">canFind("hello world",
"or")</span> returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#count"><span class="inlinecode">count</span></a></td> <td valign=top>Counts elements that are equal
to a specified value or satisfy a predicate. <span class="inlinecode">count([1, 2, 1], 1)</span>
returns <span class="inlinecode">2</span> and <span class="inlinecode">count!"a &lt; 0"([1, -3, 0])</span> returns <span class="inlinecode">1</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#countUntil"><span class="inlinecode">countUntil</span></a></td> <td valign=top><span class="inlinecode">countUntil(a, b)</span>
returns the number of steps taken in <span class="inlinecode">a</span> to reach <span class="inlinecode">b</span>; for
example, <span class="inlinecode">countUntil("hello!", "o")</span> returns <span class="inlinecode">4</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#endsWith"><span class="inlinecode">endsWith</span></a></td> <td valign=top><span class="inlinecode">endsWith("rocks", "ks")</span>
returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top><a href="#find"><span class="inlinecode">find</span></a></td> <td valign=top><span class="inlinecode">find("hello world",
"or")</span> returns <span class="inlinecode">"orld"</span> using linear search.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findAdjacent"><span class="inlinecode">findAdjacent</span></a></td> <td valign=top><span class="inlinecode">findAdjacent([1, 2,
3, 3, 4])</span> returns the subrange starting with two equal adjacent
elements, i.e. <span class="inlinecode">[3, 3, 4]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findAmong"><span class="inlinecode">findAmong</span></a></td> <td valign=top><span class="inlinecode">findAmong("abcd",
"qcx")</span> returns <span class="inlinecode">"cd"</span> because <span class="inlinecode">'c'</span> is among <span class="inlinecode">"qcx"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSkip"><span class="inlinecode">findSkip</span></a></td> <td valign=top>If <span class="inlinecode">a = "abcde"</span>, then
<span class="inlinecode">findSkip(a, "x")</span> returns <span class="inlinecode"><span class="d_keyword">false</span></span> and leaves <span class="inlinecode">a</span> unchanged,
whereas <span class="inlinecode">findSkip(a, 'c')</span> advances <span class="inlinecode">a</span> to <span class="inlinecode">"cde"</span> and
returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSplit"><span class="inlinecode">findSplit</span></a></td> <td valign=top><span class="inlinecode">findSplit("abcdefg",
"de")</span> returns the three ranges <span class="inlinecode">"abc"</span>, <span class="inlinecode">"de"</span>, and <span class="inlinecode">"fg"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSplitAfter"><span class="inlinecode">findSplitAfter</span></a></td> <td valign=top><span class="inlinecode">findSplitAfter("abcdefg", "de")</span> returns the two ranges <span class="inlinecode">"abcde"</span>
and <span class="inlinecode">"fg"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSplitBefore"><span class="inlinecode">findSplitBefore</span></a></td> <td valign=top><span class="inlinecode">findSplitBefore("abcdefg", "de")</span> returns the two ranges <span class="inlinecode">"abc"</span> and
<span class="inlinecode">"defg"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#minCount"><span class="inlinecode">minCount</span></a></td> <td valign=top><span class="inlinecode">minCount([2, 1, 1, 4,
1])</span> returns <span class="inlinecode">tuple(1, 3)</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#minPos"><span class="inlinecode">minPos</span></a></td> <td valign=top><span class="inlinecode">minPos([2, 3, 1, 3, 4,
1])</span> returns the subrange <span class="inlinecode">[1, 3, 4, 1]</span>, i.e., positions the range
at the first occurrence of its minimal element.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#skipOver"><span class="inlinecode">skipOver</span></a></td> <td valign=top>Assume <span class="inlinecode">a = "blah"</span>. Then
<span class="inlinecode">skipOver(a, "bi")</span> leaves <span class="inlinecode">a</span> unchanged and returns <span class="inlinecode"><span class="d_keyword">false</span></span>,
whereas <span class="inlinecode">skipOver(a, "bl")</span> advances <span class="inlinecode">a</span> to refer to <span class="inlinecode">"ah"</span>
and returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#startsWith"><span class="inlinecode">startsWith</span></a></td> <td valign=top><span class="inlinecode">startsWith("hello,
world", "hello")</span> returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#until"><span class="inlinecode">until</span></a></td> <td valign=top>Lazily iterates a range
until a specific value is found.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Comparison
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#cmp"><span class="inlinecode">cmp</span></a></td> <td valign=top><span class="inlinecode">cmp("abc", "abcd")</span> is <span class="inlinecode">-1</span>, <span class="inlinecode">cmp("abc", aba")</span> is <span class="inlinecode">1</span>, and <span class="inlinecode">cmp("abc", "abc")</span> is
<span class="inlinecode">0</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#equal"><span class="inlinecode">equal</span></a></td> <td valign=top>Compares ranges for
element-by-element equality, e.g. <span class="inlinecode">equal([1, 2, 3], [1.0, 2.0,
3.0])</span> returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#levenshteinDistance"><span class="inlinecode">levenshteinDistance</span></a></td> <td valign=top><span class="inlinecode">levenshteinDistance("kitten", "sitting")</span> returns <span class="inlinecode">3</span> by using the
<a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Levenshtein distance algorithm">Levenshtein distance algorithm</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#levenshteinDistanceAndPath"><span class="inlinecode">levenshteinDistanceAndPath</span></a></td> <td valign=top><span class="inlinecode">levenshteinDistanceAndPath("kitten", "sitting")</span> returns <span class="inlinecode">tuple(3,
"snnnsni")</span> by using the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Levenshtein distance algorithm">Levenshtein distance algorithm</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#max"><span class="inlinecode">max</span></a></td> <td valign=top><span class="inlinecode">max(3, 4, 2)</span> returns <span class="inlinecode">4</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#min"><span class="inlinecode">min</span></a></td> <td valign=top><span class="inlinecode">min(3, 4, 2)</span> returns <span class="inlinecode">2</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#mismatch"><span class="inlinecode">mismatch</span></a></td> <td valign=top><span class="inlinecode">mismatch("oh hi",
"ohayo")</span> returns <span class="inlinecode">tuple(" hi", "ayo")</span>.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Iteration
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#filter"><span class="inlinecode">filter</span></a></td> <td valign=top><span class="inlinecode">filter!"a &gt; 0"([1, -1, 2,
0, -3])</span> iterates over elements <span class="inlinecode">1</span>, <span class="inlinecode">2</span>, and <span class="inlinecode">0</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#filterBidirectional"><span class="inlinecode">filterBidirectional</span></a></td> <td valign=top>Similar to <span class="inlinecode">filter</span>, but also provides <span class="inlinecode">back</span> and <span class="inlinecode">popBack</span> at a small
increase in cost.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#group"><span class="inlinecode">group</span></a></td> <td valign=top><span class="inlinecode">group([5, 2, 2, 3, 3])</span>
returns a range containing the tuples <span class="inlinecode">tuple(5, 1)</span>,
<span class="inlinecode">tuple(2, 2)</span>, and <span class="inlinecode">tuple(3, 2)</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#joiner"><span class="inlinecode">joiner</span></a></td> <td valign=top><span class="inlinecode">joiner(["hello",
"world!"], ";")</span> returns a range that iterates over the characters <span class="inlinecode">"hello; world!"</span>. No new string is created - the existing inputs are
iterated.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#map"><span class="inlinecode">map</span></a></td> <td valign=top><span class="inlinecode">map!"2 * a"([1, 2, 3])</span>
lazily returns a range with the numbers <span class="inlinecode">2</span>, <span class="inlinecode">4</span>, <span class="inlinecode">6</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#reduce"><span class="inlinecode">reduce</span></a></td> <td valign=top><span class="inlinecode">reduce!"a + b"([1, 2, 3,
4])</span> returns <span class="inlinecode">10</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#splitter"><span class="inlinecode">splitter</span></a></td> <td valign=top>Lazily splits a range by a
separator.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#uniq"><span class="inlinecode">uniq</span></a></td> <td valign=top>Iterates over the unique elements
in a range, which is assumed sorted.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Sorting
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#completeSort"><span class="inlinecode">completeSort</span></a></td> <td valign=top>If <span class="inlinecode">a = [10, 20, 30]</span>
and <span class="inlinecode">b = [40, 6, 15]</span>, then <span class="inlinecode">completeSort(a, b)</span> leaves <span class="inlinecode">a =
[6, 10, 15]</span> and <span class="inlinecode">b = [20, 30, 40]</span>. The range <span class="inlinecode">a</span> must be
sorted prior to the call, and as a result the combination <span class="inlinecode"><a href="std_range.html#chain"><span class="inlinecode">std.range.chain</span></a>(a, b)</span> is sorted.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#isPartitioned"><span class="inlinecode">isPartitioned</span></a></td> <td valign=top><span class="inlinecode">isPartitioned!"a &lt;
0"([-1, -2, 1, 0, 2])</span> returns <span class="inlinecode"><span class="d_keyword">true</span></span> because the predicate is <span class="inlinecode"><span class="d_keyword">true</span></span> for a portion of the range and <span class="inlinecode"><span class="d_keyword">false</span></span> afterwards.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#isSorted"><span class="inlinecode">isSorted</span></a></td> <td valign=top><span class="inlinecode">isSorted([1, 1, 2, 3])</span>
returns <span class="inlinecode"><span class="d_keyword">true</span></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#makeIndex"><span class="inlinecode">makeIndex</span></a></td> <td valign=top>Creates a separate index
for a range.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#partialSort"><span class="inlinecode">partialSort</span></a></td> <td valign=top>If <span class="inlinecode">a = [5, 4, 3, 2,
1]</span>, then <span class="inlinecode">partialSort(a, 3)</span> leaves <span class="inlinecode">a[0 .. 3] = [1, 2,
3]</span>. The other elements of <span class="inlinecode">a</span> are left in an unspecified order.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#partition"><span class="inlinecode">partition</span></a></td> <td valign=top>Partitions a range
according to a predicate.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#schwartzSort"><span class="inlinecode">schwartzSort</span></a></td> <td valign=top>Sorts with the help of
the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Schwartzian transform">Schwartzian transform</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#sort"><span class="inlinecode">sort</span></a></td> <td valign=top>Sorts.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#topN"><span class="inlinecode">topN</span></a></td> <td valign=top>Separates the top elements in a
range.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#topNCopy"><span class="inlinecode">topNCopy</span></a></td> <td valign=top>Copies out the top elements
of a range.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Set operations
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#largestPartialIntersection"><span class="inlinecode">largestPartialIntersection</span></a></td> <td valign=top>Copies out
the values that occur most frequently in a range of ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#largestPartialIntersectionWeighted"><span class="inlinecode">largestPartialIntersectionWeighted</span></a></td> <td valign=top>Copies out the values that occur most frequently (multiplied by
per-value weights) in a range of ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#nWayUnion"><span class="inlinecode">nWayUnion</span></a></td> <td valign=top>Computes the union of a set
of sets implemented as a range of sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setDifference"><span class="inlinecode">setDifference</span></a></td> <td valign=top>Lazily computes the set
difference of two or more sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setIntersection"><span class="inlinecode">setIntersection</span></a></td> <td valign=top>Lazily computes the
set difference of two or more sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setSymmetricDifference"><span class="inlinecode">setSymmetricDifference</span></a></td> <td valign=top>Lazily
computes the symmetric set difference of two or more sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setUnion"><span class="inlinecode">setUnion</span></a></td> <td valign=top>Lazily computes the set
union of two or more sorted ranges.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Mutation
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#bringToFront"><span class="inlinecode">bringToFront</span></a></td> <td valign=top>If <span class="inlinecode">a = [1, 2, 3]</span>
and <span class="inlinecode">b = [4, 5, 6, 7]</span>, <span class="inlinecode">bringToFront(a, b)</span> leaves <span class="inlinecode">a = [4,
5, 6]</span> and <span class="inlinecode">b = [7, 1, 2, 3]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#copy"><span class="inlinecode">copy</span></a></td> <td valign=top>Copies a range to another. If
<span class="inlinecode">a = [1, 2, 3]</span> and <span class="inlinecode">b = new int[5]</span>, then <span class="inlinecode">copy(a, b)</span>
leaves <span class="inlinecode">b = [1, 2, 3, 0, 0]</span> and returns <span class="inlinecode">b[3 .. $]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#fill"><span class="inlinecode">fill</span></a></td> <td valign=top>Fills a range with a pattern,
e.g., if <span class="inlinecode">a = new int[3]</span>, then <span class="inlinecode">fill(a, 4)</span> leaves <span class="inlinecode">a = [4,
4, 4]</span> and <span class="inlinecode">fill(a, [3, 4])</span> leaves <span class="inlinecode">a = [3, 4, 3]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#initializeAll"><span class="inlinecode">initializeAll</span></a></td> <td valign=top>If <span class="inlinecode">a = [1.2, 3.4]</span>,
then <span class="inlinecode">initializeAll(a)</span> leaves <span class="inlinecode">a = [double.init,
double.init]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#move"><span class="inlinecode">move</span></a></td> <td valign=top><span class="inlinecode">move(a, b)</span> moves <span class="inlinecode">a</span>
into <span class="inlinecode">b</span>. <span class="inlinecode">move(a)</span> reads <span class="inlinecode">a</span> destructively.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#moveAll"><span class="inlinecode">moveAll</span></a></td> <td valign=top>Moves all elements from one
range to another.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#moveSome"><span class="inlinecode">moveSome</span></a></td> <td valign=top>Moves as many elements as
possible from one range to another.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#reverse"><span class="inlinecode">reverse</span></a></td> <td valign=top>If <span class="inlinecode">a = [1, 2, 3]</span>, <span class="inlinecode">reverse(a)</span> changes it to <span class="inlinecode">[3, 2, 1]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#swap"><span class="inlinecode">swap</span></a></td> <td valign=top>Swaps two values.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#swapRanges"><span class="inlinecode">swapRanges</span></a></td> <td valign=top>Swaps all elements of two
ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#uninitializedFill"><span class="inlinecode">uninitializedFill</span></a></td> <td valign=top>Fills a range
(assumed uninitialized) with a value.</td>
</tr>
</table>

<br><br>
<div><b>License</b>: <a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

</div>
<div><b>Authors</b>:<br/> &nbsp; &nbsp; &nbsp; <a href="http://erdani.com">Andrei Alexandrescu</a>

</div>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/algorithm.d">std/algorithm.d</a><br><br>

<hr><div class="row-fluid declaration"><h3>template <a class="symbol symbol-anchor" name="map" href="#map">map</a>(fun...) if (fun.length &gt;= 1)</h3></div>

<div class="declaration-content"><p>Implements the homonym function (also known as <span class="inlinecode">transform</span>) present
in many languages of functional flavor. The call <span class="inlinecode"><a class="symbol symbol-anchor" name="map" href="#map">map</a>!(fun)(range)</span>
returns a range of which elements are obtained by applying <span class="inlinecode">fun(x)</span>
left to right for all <span class="inlinecode">x</span> in <span class="inlinecode">range</span>. The original ranges are
not changed. Evaluation is done lazily. The range returned by <span class="inlinecode"><a class="symbol symbol-anchor" name="map" href="#map">map</a></span>
caches the last value such that evaluating <span class="inlinecode">front</span> multiple times
does not result in multiple calls to <span class="inlinecode">fun</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr1 = [ 1, 2, 3, 4 ];
<span class="d_keyword">int</span>[] arr2 = [ 5, 6 ];
<span class="d_keyword">auto</span> squares = <u>map</u>!(<span class="d_string">"a * a"</span>)(chain(arr1, arr2));
<span class="d_keyword">assert</span>(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));
</pre>

Multiple functions can be passed to <span class="inlinecode"><a class="symbol symbol-anchor" name="map" href="#map">map</a></span>. In that case, the
element type of <span class="inlinecode"><a class="symbol symbol-anchor" name="map" href="#map">map</a></span> is a tuple containing one element for each
function.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> arr1 = [ 1, 2, 3, 4 ];
<span class="d_keyword">foreach</span> (e; <u>map</u>!(<span class="d_string">"a + a"</span>, <span class="d_string">"a * a"</span>)(arr1))
{
    writeln(e[0], <span class="d_string">" "</span>, e[1]);
}
</pre>

You may alias <span class="inlinecode"><a class="symbol symbol-anchor" name="map" href="#map">map</a></span> with some function(s) to a symbol and use
it separately:
<br><br>

<pre class="d_code"><span class="d_keyword">alias</span> <u>map</u>!(to!string) stringize;
<span class="d_keyword">assert</span>(equal(stringize([ 1, 2, 3, 4 ]), [ <span class="d_string">"1"</span>, <span class="d_string">"2"</span>, <span class="d_string">"3"</span>, <span class="d_string">"4"</span> ]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>template <a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a>(fun...) if (fun.length &gt;= 1)</h3></div>

<div class="declaration-content"><p>Implements the homonym function (also known as <span class="inlinecode">accumulate</span>, <span class="inlinecode">compress</span>, <span class="inlinecode">inject</span>, or <span class="inlinecode">foldl</span>) present in various programming
languages of functional flavor. The call <span class="inlinecode"><a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a>!(fun)(seed,
range)</span> first assigns <span class="inlinecode">seed</span> to an internal variable <span class="inlinecode">result</span>,
also called the accumulator. Then, for each element <span class="inlinecode">x</span> in <span class="inlinecode">range</span>, <span class="inlinecode">result = fun(result, x)</span> gets evaluated. Finally, <span class="inlinecode">result</span> is returned. The one-argument version <span class="inlinecode"><a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a>!(fun)(range)</span>
works similarly, but it uses the first element of the range as the
seed (the range must be non-empty).
</p>

<p>Many aggregate range operations turn out to be solved with <span class="inlinecode"><a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a></span>
quickly and easily. The example below illustrates <span class="inlinecode"><a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a></span>'s
remarkable power and flexibility.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_comment">// Sum all elements
</span>
<span class="d_keyword">auto</span> sum = <u>reduce</u>!(<span class="d_string">"a + b"</span>)(0, arr);
<span class="d_keyword">assert</span>(sum == 15);

<span class="d_comment">// Compute the maximum of all elements
</span>
<span class="d_keyword">auto</span> largest = <u>reduce</u>!(max)(arr);
<span class="d_keyword">assert</span>(largest == 5);

<span class="d_comment">// Compute the number of odd elements
</span>
<span class="d_keyword">auto</span> odds = <u>reduce</u>!(<span class="d_string">"a + (b &amp; 1)"</span>)(0, arr);
<span class="d_keyword">assert</span>(odds == 3);

<span class="d_comment">// Compute the sum of squares
</span>
<span class="d_keyword">auto</span> ssquares = <u>reduce</u>!(<span class="d_string">"a + b * b"</span>)(0, arr);
<span class="d_keyword">assert</span>(ssquares == 55);

<span class="d_comment">// Chain multiple ranges into seed
</span>
<span class="d_keyword">int</span>[] a = [ 3, 4 ];
<span class="d_keyword">int</span>[] b = [ 100 ];
<span class="d_keyword">auto</span> r = <u>reduce</u>!(<span class="d_string">"a + b"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(r == 107);

<span class="d_comment">// Mixing convertible types is fair game, too
</span>
<span class="d_keyword">double</span>[] c = [ 2.5, 3.0 ];
<span class="d_keyword">auto</span> r1 = <u>reduce</u>!(<span class="d_string">"a + b"</span>)(chain(a, b, c));
<span class="d_keyword">assert</span>(r1 == 112.5);
</pre>

<b>Multiple functions:</b><br> Sometimes it is very useful to
compute multiple aggregates in one pass. One advantage is that the
computation is faster because the looping overhead is shared. That's
why <span class="inlinecode"><a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a></span> accepts multiple functions. If two or more functions
are passed, <span class="inlinecode"><a class="symbol symbol-anchor" name="reduce" href="#reduce">reduce</a></span> returns a <a href="std_typecons.html#Tuple"><span class="inlinecode">std.typecons.Tuple</span></a> object with
one member per passed-in function. The number of seeds must be
correspondingly increased.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">double</span>[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];
<span class="d_comment">// Compute minimum and maximum in one pass
</span>
<span class="d_keyword">auto</span> r = <u>reduce</u>!(min, max)(a);
<span class="d_comment">// The type of r is Tuple!(double, double)
</span>
<span class="d_keyword">assert</span>(r[0] == 2);  <span class="d_comment">// minimum
</span>
<span class="d_keyword">assert</span>(r[1] == 11); <span class="d_comment">// maximum
</span>

<span class="d_comment">// Compute sum and sum of squares in one pass
</span>
r = <u>reduce</u>!(<span class="d_string">"a + b"</span>, <span class="d_string">"a + b * b"</span>)(tuple(0.0, 0.0), a);
<span class="d_keyword">assert</span>(r[0] == 35);  <span class="d_comment">// sum
</span>
<span class="d_keyword">assert</span>(r[1] == 233); <span class="d_comment">// sum of squares
</span>
<span class="d_comment">// Compute average and standard deviation from the above
</span>
<span class="d_keyword">auto</span> avg = r[0] / a.length;
<span class="d_keyword">auto</span> stdev = sqrt(r[1] / a.length - avg * avg);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="fill" href="#fill">fill</a>(Range, Value)(Range <i>range</i>, Value <i>filler</i>);
</h3></div>

<div class="declaration-content"><p>Fills a range with a value.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4 ];
<u>fill</u>(a, 5);
<span class="d_keyword">assert</span>(a == [ 5, 5, 5, 5 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="fill" href="#fill">fill</a>(Range1, Range2)(Range1 <i>range</i>, Range2 <i>filler</i>);
</h3></div>

<div class="declaration-content"><p>Fills <span class="inlinecode">range</span> with a pattern copied from <span class="inlinecode">filler</span>. The length of
<span class="inlinecode">range</span> does not have to be a multiple of the length of <span class="inlinecode">filler</span>. If <span class="inlinecode">filler</span> is empty, an exception is thrown.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">int</span>[] b = [ 8, 9 ];
<u>fill</u>(a, b);
<span class="d_keyword">assert</span>(a == [ 8, 9, 8, 9, 8 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="uninitializedFill" href="#uninitializedFill">uninitializedFill</a>(Range, Value)(Range <i>range</i>, Value <i>filler</i>);
</h3></div>

<div class="declaration-content"><p>Fills a range with a value. Assumes that the range does not currently
contain meaningful content. This is of interest for structs that
define copy constructors (for all other types, fill and
<a class="symbol symbol-anchor" name="uninitializedFill" href="#uninitializedFill">uninitializedFill</a> are equivalent).
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">struct</span> S { ... }
S[] s = (<span class="d_keyword">cast</span>(S*) malloc(5 * S.sizeof))[0 .. 5];
<u>uninitializedFill</u>(s, 42);
<span class="d_keyword">assert</span>(s == [ 42, 42, 42, 42, 42 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="initializeAll" href="#initializeAll">initializeAll</a>(Range)(Range <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Initializes all elements of a range with their <span class="inlinecode">.init</span>
value. Assumes that the range does not currently contain meaningful
content.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">struct</span> S { ... }
S[] s = (<span class="d_keyword">cast</span>(S*) malloc(5 * S.sizeof))[0 .. 5];
<u>initializeAll</u>(s);
<span class="d_keyword">assert</span>(s == [ 0, 0, 0, 0, 0 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>template <a class="symbol symbol-anchor" name="filter" href="#filter">filter</a>(alias pred) if (is(typeof(unaryFun!(pred))))</h3></div>

<div class="declaration-content"><p>Implements the homonym function present in various programming
languages of functional flavor. The call <span class="inlinecode"><a class="symbol symbol-anchor" name="filter" href="#filter">filter</a>!(fun)(range)</span>
returns a new range only containing elements <span class="inlinecode">x</span> in <span class="inlinecode">r</span> for
which <span class="inlinecode">predicate(x)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_comment">// Sum all elements
</span>
<span class="d_keyword">auto</span> small = <u>filter</u>!(<span class="d_string">"a &lt; 3"</span>)(arr);
<span class="d_keyword">assert</span>(equal(small, [ 1, 2 ]));
<span class="d_comment">// In combination with chain() to span multiple ranges
</span>
<span class="d_keyword">int</span>[] a = [ 3, -2, 400 ];
<span class="d_keyword">int</span>[] b = [ 100, -101, 102 ];
<span class="d_keyword">auto</span> r = <u>filter</u>!(<span class="d_string">"a &gt; 0"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(equal(r, [ 3, 400, 100, 102 ]));
<span class="d_comment">// Mixing convertible types is fair game, too
</span>
<span class="d_keyword">double</span>[] c = [ 2.5, 3.0 ];
<span class="d_keyword">auto</span> r1 = <u>filter</u>!(<span class="d_string">"cast(int) a != a"</span>)(chain(c, a, b));
<span class="d_keyword">assert</span>(equal(r1, [ 2.5 ]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>template <a class="symbol symbol-anchor" name="filterBidirectional" href="#filterBidirectional">filterBidirectional</a>(alias pred)</h3></div>

<div class="declaration-content"><p>Similar to <span class="inlinecode">filter</span>, except it defines a bidirectional
 range. There is a speed disadvantage - the constructor spends time
 finding the last element in the range that satisfies the filtering
 condition (in addition to finding the first one). The advantage is
 that the filtered range can be spanned from both directions. Also,
 <a href="std_range.html#retro"><span class="inlinecode">std.range.retro</span></a> can be applied against the filtered range.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">auto</span> small = <u>filterBidirectional</u>!(<span class="d_string">"a &lt; 3"</span>)(arr);
<span class="d_keyword">assert</span>(small.back == 2);
<span class="d_keyword">assert</span>(equal(small, [ 1, 2 ]));
<span class="d_keyword">assert</span>(equal(retro(small), [ 2, 1 ]));
<span class="d_comment">// In combination with chain() to span multiple ranges
</span>
<span class="d_keyword">int</span>[] a = [ 3, -2, 400 ];
<span class="d_keyword">int</span>[] b = [ 100, -101, 102 ];
<span class="d_keyword">auto</span> r = <u>filterBidirectional</u>!(<span class="d_string">"a &gt; 0"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(r.back == 102);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="move" href="#move">move</a>(T)(ref T <i>source</i>, ref T <i>target</i>);
<br>T <a class="symbol symbol-anchor" name="move" href="#move">move</a>(T)(ref T <i>src</i>);
</h3></div>

<div class="declaration-content"><p>Moves <span class="inlinecode">source</span> into <span class="inlinecode">target</span> via a destructive
copy. Specifically: <ul><li>If <span class="inlinecode">hasAliasing!T</span> is <span class="d_keyword">true</span> (see
<a href="std_traits.html#hasAliasing"><span class="inlinecode">std.traits.hasAliasing</span></a>), then the representation of <span class="inlinecode">source</span>
is bitwise copied into <span class="inlinecode">target</span> and then <span class="inlinecode">source = T.init</span> is
evaluated.</li>  <li>Otherwise, <span class="inlinecode">target = source</span> is evaluated.</li></ul> See
also <a href="std_exception.html#pointsTo"><span class="inlinecode">std.exception.pointsTo</span></a>.
</p>

<b>Preconditions:</b><br>
<span class="inlinecode">&source == &target || !pointsTo(source, source)</span><br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Range2 <a class="symbol symbol-anchor" name="moveAll" href="#moveAll">moveAll</a>(Range1, Range2)(Range1 <i>src</i>, Range2 <i>tgt</i>);
</h3></div>

<div class="declaration-content"><p>For each element <span class="inlinecode">a</span> in <span class="inlinecode">src</span> and each element <span class="inlinecode">b</span> in <span class="inlinecode">tgt</span> in lockstep in increasing order, calls <span class="inlinecode">move(a, b)</span>. Returns
the leftover portion of <span class="inlinecode">tgt</span>. Throws an exeption if there is not
enough room in <span class="inlinecode">tgt</span> to acommodate all of <span class="inlinecode">src</span>.
</p>

<b>Preconditions:</b><br>
<span class="inlinecode">walkLength(src) &lt;= walkLength(tgt)</span><br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Tuple!(Range1,Range2) <a class="symbol symbol-anchor" name="moveSome" href="#moveSome">moveSome</a>(Range1, Range2)(Range1 <i>src</i>, Range2 <i>tgt</i>);
</h3></div>

<div class="declaration-content"><p>For each element <span class="inlinecode">a</span> in <span class="inlinecode">src</span> and each element <span class="inlinecode">b</span> in <span class="inlinecode">tgt</span> in lockstep in increasing order, calls <span class="inlinecode">move(a, b)</span>. Stops
when either <span class="inlinecode">src</span> or <span class="inlinecode">tgt</span> have been exhausted. Returns the
leftover portions of the two ranges.</p>


</div>

<hr><div class="row-fluid declaration"><h3>pure nothrow @trusted void <a class="symbol symbol-anchor" name="swap" href="#swap">swap</a>(T)(ref T <i>lhs</i>, ref T <i>rhs</i>);
</h3></div>

<div class="declaration-content"><p>Swaps <span class="inlinecode">lhs</span> and <span class="inlinecode">rhs</span>. See also <a href="std_exception.html#pointsTo"><span class="inlinecode">std.exception.pointsTo</span></a>.
</p>

<b>Preconditions:</b><br>
<span class="inlinecode">!pointsTo(lhs, lhs) &amp;&amp; !pointsTo(lhs, rhs) &amp;&amp; !pointsTo(rhs, lhs)
&amp;&amp; !pointsTo(rhs, rhs)</span><br><br>

</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="splitter" href="#splitter">splitter</a>(Range, Separator)(Range <i>r</i>, Separator <i>s</i>);
</h3></div>

<div class="declaration-content"><p>Splits a range using an element as a separator. This can be used with
any range type, but is most popular with string types.
</p>

<p>Two adjacent separators are considered to surround an empty element in
the split range.
<br><br>

If the empty range is given, the result is a range with one empty
element. If a range with one separator is given, the result is a range
with two empty elements.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(equal(<u>splitter</u>(<span class="d_string">"hello  world"</span>, ' '), [ <span class="d_string">"hello"</span>, <span class="d_string">""</span>, <span class="d_string">"world"</span> ]));
<span class="d_keyword">int</span>[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];
<span class="d_keyword">int</span>[][] w = [ [1, 2], [], [3], [4, 5] ];
<span class="d_keyword">assert</span>(equal(<u>splitter</u>(a, 0), w));
a = <span class="d_keyword">null</span>;
<span class="d_keyword">assert</span>(equal(<u>splitter</u>(a, 0), [ (<span class="d_keyword">int</span>[]).init ]));
a = [ 0 ];
<span class="d_keyword">assert</span>(equal(<u>splitter</u>(a, 0), [ (<span class="d_keyword">int</span>[]).init, (<span class="d_keyword">int</span>[]).init ]));
a = [ 0, 1 ];
<span class="d_keyword">assert</span>(equal(<u>splitter</u>(a, 0), [ [], [1] ]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="splitter" href="#splitter">splitter</a>(Range, Separator)(Range <i>r</i>, Separator <i>s</i>);
</h3></div>

<div class="declaration-content"><p>Splits a range using another range as a separator. This can be used
with any range type, but is most popular with string types.</p>


</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="joiner" href="#joiner">joiner</a>(RoR, Separator)(RoR <i>r</i>, Separator <i>sep</i>);
</h3></div>

<div class="declaration-content"><p>Lazily joins a range of ranges with a separator. The separator itself
is a range.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(equal(<u>joiner</u>([<span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(equal(<u>joiner</u>([<span class="d_string">""</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"xyz"</span>));
<span class="d_keyword">assert</span>(equal(<u>joiner</u>([<span class="d_string">""</span>, <span class="d_string">"abc"</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"xyzabc"</span>));
<span class="d_keyword">assert</span>(equal(<u>joiner</u>([<span class="d_string">"abc"</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"abcxyz"</span>));
<span class="d_keyword">assert</span>(equal(<u>joiner</u>([<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"abcxyzdef"</span>));
<span class="d_keyword">assert</span>(equal(<u>joiner</u>([<span class="d_string">"Mary"</span>, <span class="d_string">"has"</span>, <span class="d_string">"a"</span>, <span class="d_string">"little"</span>, <span class="d_string">"lamb"</span>], <span class="d_string">"..."</span>),
  <span class="d_string">"Mary...has...a...little...lamb"</span>));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="uniq" href="#uniq">uniq</a>(alias pred = "a == b", Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Iterates unique consecutive elements of the given range (functionality
akin to the <a href="http://wikipedia.org/wiki/Uniq">uniq</a> system
utility). Equivalence of elements is assessed by using the predicate
<span class="inlinecode">pred</span>, by default <span class="inlinecode">"a == b"</span>. If the given range is
bidirectional, <span class="inlinecode"><a class="symbol symbol-anchor" name="uniq" href="#uniq">uniq</a></span> also yields a bidirectional range.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
<span class="d_keyword">assert</span>(equal(<u>uniq</u>(arr), [ 1, 2, 3, 4, 5 ][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="Group" href="#Group">Group</a>(alias pred,R) if (isInputRange!(R));
<br>Group!(pred,Range) <a class="symbol symbol-anchor" name="group" href="#group">group</a>(alias pred = "a == b", Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Similarly to <span class="inlinecode">uniq</span>, <span class="inlinecode">group</span> iterates unique consecutive
elements of the given range. The element type is <span class="inlinecode">Tuple!(ElementType!R, uint)</span> because it includes the count of
equivalent elements seen. Equivalence of elements is assessed by using
the predicate <span class="inlinecode">pred</span>, by default <span class="inlinecode">"a == b"</span>.
</p>

<p><span class="inlinecode"><a class="symbol symbol-anchor" name="Group" href="#Group">Group</a></span> is an input range if <span class="inlinecode">R</span> is an input range, and a
forward range in all other cases.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
<span class="d_keyword">assert</span>(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),
    tuple(4, 3u), tuple(5, 1u) ][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>R <a class="symbol symbol-anchor" name="find" href="#find">find</a>(alias pred = "a == b", R, E)(R <i>haystack</i>, E <i>needle</i>);
</h3></div>

<div class="declaration-content"><p>Finds an individual element in an input range. Elements of <span class="inlinecode">haystack</span> are compared with <span class="inlinecode">needle</span> by using predicate <span class="inlinecode">pred</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">walkLength(haystack)</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/find.html">STL's find</a>.
</p>

<p>To find the last occurence of <span class="inlinecode">needle</span> in <span class="inlinecode">haystack</span>, call <span class="inlinecode"><a class="symbol symbol-anchor" name="find" href="#find">find</a>(retro(haystack), needle)</span>. See also <a href="std_range.html#retro"><span class="inlinecode">std.range.retro</span></a>.

</p>
<b>Parameters</b> <div><table class="table table-condensed table-bordered"><tr><td class="span2">haystack</td>
<td>The range searched in.</td>
</tr>
<tr><td class="span2">needle</td>
<td>The element searched for.</td>
</tr>
</table></div>
<b>Constraints:</b><br>
<span class="inlinecode">isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle)
: bool))</span>

<br><br>
<div><b>Returns</b>:<br/> &nbsp; &nbsp; &nbsp; <span class="inlinecode">haystack</span> advanced such that <span class="inlinecode">binaryFun!pred(haystack.front,
needle)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span> (if no such position exists, returns <span class="inlinecode">haystack</span> after exhaustion).

</div>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<u>find</u>(<span class="d_string">"hello, world"</span>, ',') == <span class="d_string">", world"</span>);
<span class="d_keyword">assert</span>(<u>find</u>([1, 2, 3, 5], 4) == []);
<span class="d_keyword">assert</span>(<u>find</u>(SList!<span class="d_keyword">int</span>(1, 2, 3, 4, 5)[], 4) == SList!<span class="d_keyword">int</span>(4, 5)[]);
<span class="d_keyword">assert</span>(<u>find</u>!<span class="d_string">"a &gt; b"</span>([1, 2, 3, 5], 2) == [3, 5]);

<span class="d_keyword">auto</span> a = [ 1, 2, 3 ];
<span class="d_keyword">assert</span>(<u>find</u>(a, 5).empty);       <span class="d_comment">// not found
</span>
<span class="d_keyword">assert</span>(!<u>find</u>(a, 2).empty);      <span class="d_comment">// found
</span>

<span class="d_comment">// Case-insensitive find of a string
</span>
string[] s = [ <span class="d_string">"Hello"</span>, <span class="d_string">"world"</span>, <span class="d_string">"!"</span> ];
<span class="d_keyword">assert</span>(!<u>find</u>!(<span class="d_string">"toLower(a) == b"</span>)(s, <span class="d_string">"hello"</span>).empty);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>R1 <a class="symbol symbol-anchor" name="find" href="#find">find</a>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>);
</h3></div>

<div class="declaration-content"><p>Finds a forward range in another. Elements are compared for
equality. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">walkLength(haystack) * walkLength(needle)</span><b><i>)</i></b>
comparisons in the worst case. Specializations taking advantage of
bidirectional or random access (where present) may accelerate search
depending on the statistics of the two ranges' content.
</p>

<b>Parameters</b> <div><table class="table table-condensed table-bordered"><tr><td class="span2">haystack</td>
<td>The range searched in.</td>
</tr>
<tr><td class="span2">needle</td>
<td>The range searched for.</td>
</tr>
</table></div>
<b>Constraints:</b><br>
<span class="inlinecode">isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp;
is(typeof(binaryFun!pred(haystack.front, needle.front) : bool))</span>

<br><br>
<div><b>Returns</b>:<br/> &nbsp; &nbsp; &nbsp; <span class="inlinecode">haystack</span> advanced such that <span class="inlinecode">needle</span> is a prefix of it (if no
such position exists, returns <span class="inlinecode">haystack</span> advanced to termination).
<br><br>

<pre class="d_code"><span class="d_keyword">assert</span>(<u>find</u>(<span class="d_string">"hello, world"</span>, <span class="d_string">"World"</span>).empty);
<span class="d_keyword">assert</span>(<u>find</u>(<span class="d_string">"hello, world"</span>, <span class="d_string">"wo"</span>) == <span class="d_string">"world"</span>);
<span class="d_keyword">assert</span>(<u>find</u>([1, 2, 3, 4], SList!(2, 3)[]) == [2, 3, 4]);
</pre>
</div>

</div>

<hr><div class="row-fluid declaration"><h3>Tuple!(Range,size_t) <a class="symbol symbol-anchor" name="find" href="#find">find</a>(alias pred = "a == b", Range, Ranges...)(Range <i>haystack</i>, Ranges <i>needles</i>);
<br>struct <a class="symbol symbol-anchor" name="BoyerMooreFinder" href="#BoyerMooreFinder">BoyerMooreFinder</a>(alias pred,Range);
<br>BoyerMooreFinder!(binaryFun!(pred),Range) <a class="symbol symbol-anchor" name="boyerMooreFinder" href="#boyerMooreFinder">boyerMooreFinder</a>(alias pred = "a == b", Range)(Range <i>needle</i>);
</h3></div>

<div class="declaration-content"><p>Finds two or more <span class="inlinecode">needles</span> into a <span class="inlinecode">haystack</span>. The predicate <span class="inlinecode">pred</span> is used throughout to compare elements. By default, elements are
compared for equality.
</p>

<b>Parameters</b> <div><table class="table table-condensed table-bordered"><tr><td class="span2">haystack</td>
<td>The target of the search. Must be an <a href="../glossary.html#input
range">input
range</a>. If any of <span class="inlinecode">needles</span> is a range with elements comparable to
elements in <span class="inlinecode">haystack</span>, then <span class="inlinecode">haystack</span> must be a <a href="../glossary.html#forward range">forward range</a> such that the search can backtrack.</td>
</tr>
<tr><td class="span2">needles</td>
<td>One or more items to search for. Each of <span class="inlinecode">needles</span> must
be either comparable to one element in <span class="inlinecode">haystack</span>, or be itself a
<a href="../glossary.html#forward range">forward range</a> with elements comparable with elements in
<span class="inlinecode">haystack</span>.</td>
</tr>
</table></div>
<div><b>Returns</b>:<br/> &nbsp; &nbsp; &nbsp; A tuple containing <span class="inlinecode">haystack</span> positioned to match one of the
needles and also the 1-based index of the matching element in <span class="inlinecode">needles</span> (0 if none of <span class="inlinecode">needles</span> matched, 1 if <span class="inlinecode">needles[0]</span>
matched, 2 if <span class="inlinecode">needles[1]</span> matched...). The first needle to be found
will be the one that matches. If multiple needles are found at the
same spot in the range, then the shortest one is the one which matches
(if multiple needles of the same length are found at the same spot (e.g
<span class="inlinecode">"a"</span> and <span class="inlinecode">'a'</span>), then the left-most of them in the argument list
matches).
<br><br>

The relationship between <span class="inlinecode">haystack</span> and <span class="inlinecode">needles</span> simply means
that one can e.g. search for individual <span class="inlinecode">int</span>s or arrays of <span class="inlinecode">int</span>s in an array of <span class="inlinecode">int</span>s. In addition, if elements are
individually comparable, searches of heterogeneous types are allowed
as well: a <span class="inlinecode">double[]</span> can be searched for an <span class="inlinecode">int</span> or a <span class="inlinecode">short[]</span>, and conversely a <span class="inlinecode">long</span> can be searched for a <span class="inlinecode">float</span>
or a <span class="inlinecode">double[]</span>. This makes for efficient searches without the need
to coerce one side of the comparison into the other's side type.

</div>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 4, 2, 3 ];
<span class="d_keyword">assert</span>(<u>find</u>(a, 4) == [ 4, 2, 3 ]);
<span class="d_keyword">assert</span>(<u>find</u>(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);
<span class="d_keyword">assert</span>(<u>find</u>(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));
<span class="d_comment">// Mixed types allowed if comparable
</span>
<span class="d_keyword">assert</span>(<u>find</u>(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));
</pre>

The complexity of the search is <b><i>&Omicron;</i>(</b><span class="inlinecode">haystack.length *
max(needles.length)</span><b><i>)</i></b>. (For needles that are individual items, length
is considered to be 1.) The strategy used in searching several
subranges at once maximizes cache usage by moving in <span class="inlinecode">haystack</span> as
few times as possible.<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Range <a class="symbol symbol-anchor" name="find" href="#find">find</a>(alias pred, Range)(Range <i>haystack</i>);
</h3></div>

<div class="declaration-content"><p>Advances the input range <span class="inlinecode">haystack</span> by calling <span class="inlinecode">haystack.popFront</span>
until either <span class="inlinecode">pred(haystack.front)</span>, or <span class="inlinecode">haystack.empty</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">haystack.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/find_if.html">STL's find_if</a>.
</p>

<p>To <a class="symbol symbol-anchor" name="find" href="#find">find</a> the last element of a bidirectional <span class="inlinecode">haystack</span> satisfying
<span class="inlinecode">pred</span>, call <span class="inlinecode"><a class="symbol symbol-anchor" name="find" href="#find">find</a>!(pred)(retro(haystack))</span>. See also <a href="std_range.html#retro"><span class="inlinecode">std.range.retro</span></a>.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> arr = [ 1, 2, 3, 4, 1 ];
<span class="d_keyword">assert</span>(<u>find</u>!(<span class="d_string">"a &gt; 2"</span>)(arr) == [ 3, 4, 1 ]);

<span class="d_comment">// with predicate alias
</span>
<span class="d_keyword">bool</span> pred(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 1 &gt; 1.5; }
<span class="d_keyword">assert</span>(<u>find</u>!(pred)(arr) == arr);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="findSkip" href="#findSkip">findSkip</a>(alias pred = "a == b", R1, R2)(ref R1 <i>haystack</i>, R2 <i>needle</i>);
</h3></div>

<div class="declaration-content"><p>If <span class="inlinecode">needle</span> occurs in <span class="inlinecode">haystack</span>, positions <span class="inlinecode">haystack</span>
 right after the first occurrence of <span class="inlinecode">needle</span> and returns <span class="inlinecode"><span class="d_keyword">true</span></span>. Otherwise, leaves <span class="inlinecode">haystack</span> as is and returns <span class="inlinecode"><span class="d_keyword">false</span></span>.
</p>

<b>Example:</b><br>
<pre class="d_code">string s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(<u>findSkip</u>(s, <span class="d_string">"cd"</span>) &amp;&amp; s == <span class="d_string">"ef"</span>);
s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(!<u>findSkip</u>(s, <span class="d_string">"cxd"</span>) &amp;&amp; s == <span class="d_string">"abcdef"</span>);
<span class="d_keyword">assert</span>(<u>findSkip</u>(s, <span class="d_string">"def"</span>) &amp;&amp; s.empty);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="findSplit" href="#findSplit">findSplit</a>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>);
<br>auto <a class="symbol symbol-anchor" name="findSplitBefore" href="#findSplitBefore">findSplitBefore</a>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>);
<br>auto <a class="symbol symbol-anchor" name="findSplitAfter" href="#findSplitAfter">findSplitAfter</a>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>);
</h3></div>

<div class="declaration-content"><p>These functions find the first occurrence of <span class="inlinecode">needle</span> in <span class="inlinecode">haystack</span> and then split <span class="inlinecode">haystack</span> as follows.
</p>

<p><span class="inlinecode"><a class="symbol symbol-anchor" name="findSplit" href="#findSplit">findSplit</a></span> returns a tuple <span class="inlinecode">result</span> containing <i>three</i>
ranges. <span class="inlinecode">result[0]</span> is the portion of <span class="inlinecode">haystack</span> before <span class="inlinecode">needle</span>, <span class="inlinecode">result[1]</span> is the portion of <span class="inlinecode">haystack</span> that matches
<span class="inlinecode">needle</span>, and <span class="inlinecode">result[2]</span> is the portion of <span class="inlinecode">haystack</span> after
the match. If <span class="inlinecode">needle</span> was not found, <span class="inlinecode">result[0]</span>
comprehends <span class="inlinecode">haystack</span> entirely and <span class="inlinecode">result[1]</span> and (D result[2]
are empty.
<br><br>

<span class="inlinecode">findSplitBefore</span> returns a tuple <span class="inlinecode">result</span> containing two
ranges. <span class="inlinecode">result[0]</span> is the portion of <span class="inlinecode">haystack</span> before <span class="inlinecode">needle</span>, and <span class="inlinecode">result[1]</span> is the balance of <span class="inlinecode">haystack</span> starting
with the match. If <span class="inlinecode">needle</span> was not found, <span class="inlinecode">result[0]</span>
comprehends <span class="inlinecode">haystack</span> entirely and <span class="inlinecode">result[1]</span> is empty.
<br><br>

<span class="inlinecode">findSplitAfter</span> returns a tuple <span class="inlinecode">result</span> containing two ranges.
<span class="inlinecode">result[0]</span> is the portion of <span class="inlinecode">haystack</span> up to and including the
match, and <span class="inlinecode">result[1]</span> is the balance of <span class="inlinecode">haystack</span> starting
after the match. If <span class="inlinecode">needle</span> was not found, <span class="inlinecode">result[0]</span> is empty
and <span class="inlinecode">result[1]</span> is <span class="inlinecode">haystack</span>.
<br><br>

In all cases, the concatenation of the returned ranges spans the
entire <span class="inlinecode">haystack</span>.
<br><br>

If <span class="inlinecode">haystack</span> is a random-access range, all three components of the
tuple have the same type as <span class="inlinecode">haystack</span>. Otherwise, <span class="inlinecode">haystack</span>
must be a forward range and the type of <span class="inlinecode">result[0]</span> and <span class="inlinecode">result[1]</span> is the same as <a href="std_range.html#takeExactly"><span class="inlinecode">std.range.takeExactly</span></a>.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
<span class="d_keyword">auto</span> r = <u>findSplit</u>(a, [9, 1]);
<span class="d_keyword">assert</span>(r[0] == a);
<span class="d_keyword">assert</span>(r[1].empty);
<span class="d_keyword">assert</span>(r[2].empty);
r = <u>findSplit</u>(a, [ 3, 4 ]);
<span class="d_keyword">assert</span>(r[0] == a[0 .. 2]);
<span class="d_keyword">assert</span>(r[1] == a[2 .. 4]);
<span class="d_keyword">assert</span>(r[2] == a[4 .. $]);
<span class="d_keyword">auto</span> r1 = findSplitBefore(a, [ 7, 8 ]);
<span class="d_keyword">assert</span>(r1[0] == a[0 .. 6]);
<span class="d_keyword">assert</span>(r1[1] == a[6 .. $]);
<span class="d_keyword">auto</span> r1 = findSplitAfter(a, [ 7, 8 ]);
<span class="d_keyword">assert</span>(r1[0] == a);
<span class="d_keyword">assert</span>(r1[1].empty);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>sizediff_t <a class="symbol symbol-anchor" name="countUntil" href="#countUntil">countUntil</a>(alias pred = "a == b", R, N)(R <i>haystack</i>, N <i>needle</i>);
</h3></div>

<div class="declaration-content"><p>Returns the number of elements which must be popped from the front of
    <span class="inlinecode">haystack</span> before reaching an element for which
    <span class="inlinecode">startsWith!pred(haystack, needle)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>. If
    <span class="inlinecode">startsWith!pred(haystack, needle)</span> is not <span class="inlinecode"><span class="d_keyword">true</span></span> for any element in
    <span class="inlinecode">haystack</span>, then -1 is returned.
</p>

<p><span class="inlinecode">needle</span> may be either an element or a range.

</p>
<div><b>Examples</b>:<br/> &nbsp; &nbsp; &nbsp; <pre class="d_code"><span class="d_keyword">assert</span>(<u>countUntil</u>(<span class="d_string">"hello world"</span>, <span class="d_string">"world"</span>) == 6);
<span class="d_keyword">assert</span>(<u>countUntil</u>(<span class="d_string">"hello world"</span>, 'r') == 8);
<span class="d_keyword">assert</span>(<u>countUntil</u>(<span class="d_string">"hello world"</span>, <span class="d_string">"programming"</span>) == -1);
<span class="d_keyword">assert</span>(<u>countUntil</u>([0, 7, 12, 22, 9], [12, 22]) == 2);
<span class="d_keyword">assert</span>(<u>countUntil</u>([0, 7, 12, 22, 9], 9) == 4);
<span class="d_keyword">assert</span>(<u>countUntil</u>!<span class="d_string">"a &gt; b"</span>([0, 7, 12, 22, 9], 20) == 3);
</pre>
</div>

</div>

<hr><div class="row-fluid declaration"><h3>sizediff_t <a class="symbol symbol-anchor" name="countUntil" href="#countUntil">countUntil</a>(alias pred, R)(R <i>haystack</i>);
</h3></div>

<div class="declaration-content"><p>Returns the number of elements which must be popped from <span class="inlinecode">haystack</span>
    before <span class="inlinecode">pred(haystack.front)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>.
</p>

<div><b>Examples</b>:<br/> &nbsp; &nbsp; &nbsp; <pre class="d_code"><span class="d_keyword">assert</span>(<u>countUntil</u>!(std.uni.isWhite)(<span class="d_string">"hello world"</span>) == 5);
<span class="d_keyword">assert</span>(<u>countUntil</u>!(std.ascii.isDigit)(<span class="d_string">"hello world"</span>) == -1);
<span class="d_keyword">assert</span>(<u>countUntil</u>!<span class="d_string">"a &gt; 20"</span>([0, 7, 12, 22, 9]) == 3);
</pre>
</div>

</div>

<hr><div class="row-fluid declaration"><h3>sizediff_t <a class="symbol symbol-anchor" name="indexOf" href="#indexOf">indexOf</a>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>);
</h3></div>

<div class="declaration-content"><p><font color=red>Scheduled for deprecation. Please use <a href="std_algorithm.html#countUntil"><span class="inlinecode">std.algorithm.countUntil</span></a>
        instead.</font>
</p>

<p>Same as <span class="inlinecode">countUntil</span>. This symbol has been scheduled for
 deprecation because it is easily confused with the homonym function
 in <span class="inlinecode">std.string</span>.</p>

</div>

<hr><div class="row-fluid declaration"><h3>enum <a class="symbol symbol-anchor" name="OpenRight" href="#OpenRight">OpenRight</a>;
</h3></div>

<div class="declaration-content"><p>Interval option specifier for <span class="inlinecode">until</span> (below) and others.</p>


<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="no" href="#no">no</a></h3></div>

<div class="declaration-content"><p>Interval is closed to the right (last element included)</p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="yes" href="#yes">yes</a></h3></div>

<div class="declaration-content"><p>Interval is open to the right (last element is not included)</p>


</div>

</div>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="Until" href="#Until">Until</a>(alias pred,Range,Sentinel) if (isInputRange!(Range));
<br>Until!(pred,Range,Sentinel) <a class="symbol symbol-anchor" name="until" href="#until">until</a>(alias pred = "a == b", Range, Sentinel)(Range <i>range</i>, Sentinel <i>sentinel</i>, OpenRight <i>openRight</i> = OpenRight.yes);
<br>Until!(pred,Range,void) <a class="symbol symbol-anchor" name="until" href="#until">until</a>(alias pred, Range)(Range <i>range</i>, OpenRight <i>openRight</i> = OpenRight.yes);
</h3></div>

<div class="declaration-content"><p>Lazily iterates <span class="inlinecode">range</span> until value <span class="inlinecode">sentinel</span> is found, at
which point it stops.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];
<span class="d_keyword">assert</span>(equal(a.until(7), [1, 2, 4][]));
<span class="d_keyword">assert</span>(equal(a.until(7, OpenRight.no), [1, 2, 4, 7][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>uint <a class="symbol symbol-anchor" name="startsWith" href="#startsWith">startsWith</a>(alias pred = "a == b", Range, Ranges...)(Range <i>doesThisStart</i>, Ranges <i>withOneOfThese</i>);
<br>bool <a class="symbol symbol-anchor" name="startsWith" href="#startsWith">startsWith</a>(alias pred = "a == b", R1, R2)(R1 <i>doesThisStart</i>, R2 <i>withThis</i>);
<br>bool <a class="symbol symbol-anchor" name="startsWith" href="#startsWith">startsWith</a>(alias pred = "a == b", R, E)(R <i>doesThisStart</i>, E <i>withThis</i>);
</h3></div>

<div class="declaration-content"><p>If the range <span class="inlinecode">doesThisStart</span> starts with <i>any</i> of the <span class="inlinecode">withOneOfThese</span> ranges or elements, returns 1 if it starts with <span class="inlinecode">withOneOfThese[0]</span>, 2 if it starts with <span class="inlinecode">withOneOfThese[1]</span>, and so
on. If none match, returns 0. In the case where <span class="inlinecode">doesThisStart</span> starts
with multiple of the ranges or elements in <span class="inlinecode">withOneOfThese</span>, then the
shortest one matches (if there are two which match which are of the same
length (e.g. <span class="inlinecode">"a"</span> and <span class="inlinecode">'a'</span>), then the left-most of them in the argument
list matches).
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>));
<span class="d_keyword">assert</span>(!<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>));
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, 'a', <span class="d_string">"b"</span>) == 1);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>, <span class="d_string">"a"</span>) == 2);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>, <span class="d_string">"a"</span>) == 1);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"ab"</span>, <span class="d_string">"a"</span>) == 2);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"a"</span>, <span class="d_string">"b"</span>) == 2);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aa"</span>, <span class="d_string">"ab"</span>) == 3);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"sab"</span>) == 0);
<span class="d_keyword">assert</span>(<u>startsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"a"</span>, <span class="d_string">"sab"</span>) == 3);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="skipOver" href="#skipOver">skipOver</a>(alias pred = "a == b", R1, R2)(ref R1 <i>r1</i>, R2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>If <span class="inlinecode">startsWith(r1, r2)</span>, consume the corresponding elements off <span class="inlinecode">r1</span> and return <span class="inlinecode"><span class="d_keyword">true</span></span>. Otherwise, leave <span class="inlinecode">r1</span> unchanged and
return <span class="inlinecode"><span class="d_keyword">false</span></span>.</p>


</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="skipOver" href="#skipOver">skipOver</a>(alias pred = "a == b", R, E)(ref R <i>r</i>, E <i>e</i>);
</h3></div>

<div class="declaration-content"><p>Checks whether a range starts with an element, and if so, consume that
element off <span class="inlinecode">r</span> and return <span class="inlinecode"><span class="d_keyword">true</span></span>. Otherwise, leave <span class="inlinecode">r</span>
unchanged and return <span class="inlinecode"><span class="d_keyword">false</span></span>.</p>


</div>

<hr><div class="row-fluid declaration"><h3>uint <a class="symbol symbol-anchor" name="endsWith" href="#endsWith">endsWith</a>(alias pred = "a == b", Range, Ranges...)(Range <i>doesThisEnd</i>, Ranges <i>withOneOfThese</i>);
<br>bool <a class="symbol symbol-anchor" name="endsWith" href="#endsWith">endsWith</a>(alias pred = "a == b", R1, R2)(R1 <i>doesThisEnd</i>, R2 <i>withThis</i>);
<br>bool <a class="symbol symbol-anchor" name="endsWith" href="#endsWith">endsWith</a>(alias pred = "a == b", R, E)(R <i>doesThisEnd</i>, E <i>withThis</i>);
</h3></div>

<div class="declaration-content"><p>The reciprocal of <span class="inlinecode">startsWith</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(!<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>));
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>, 'c') == 2);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"c"</span>, <span class="d_string">"a"</span>) == 1);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"c"</span>, <span class="d_string">"c"</span>) == 1);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"bc"</span>, <span class="d_string">"c"</span>) == 2);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"c"</span>, <span class="d_string">"b"</span>) == 2);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aa"</span>, <span class="d_string">"bc"</span>) == 3);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"sab"</span>) == 0);
<span class="d_keyword">assert</span>(<u>endsWith</u>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, 'c', <span class="d_string">"sab"</span>) == 3);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="commonPrefix" href="#commonPrefix">commonPrefix</a>(alias pred = "a == b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Returns the common prefix of two ranges. Example:
</p>

<p><pre class="d_code"><span class="d_keyword">assert</span>(<u>commonPrefix</u>(<span class="d_string">"hello, world"</span>, <span class="d_string">"hello, there"</span>) == <span class="d_string">"hello, "</span>);
</pre>

The type of the result is the same as <span class="inlinecode">takeExactly(r1, n)</span>, where
<span class="inlinecode">n</span> is the number of elements that both ranges start with.</p>

</div>

<hr><div class="row-fluid declaration"><h3>Range <a class="symbol symbol-anchor" name="findAdjacent" href="#findAdjacent">findAdjacent</a>(alias pred = "a == b", Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Advances <span class="inlinecode">r</span> until it finds the first two adjacent elements <span class="inlinecode">a</span>,
<span class="inlinecode">b</span> that satisfy <span class="inlinecode">pred(a, b)</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b>
evaluations of <span class="inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/adjacent_find.html">STL's adjacent_find</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
<span class="d_keyword">auto</span> r = <u>findAdjacent</u>(a);
<span class="d_keyword">assert</span>(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);
p = <u>findAdjacent</u>!(<span class="d_string">"a &lt; b"</span>)(a);
<span class="d_keyword">assert</span>(p == [ 7, 8, 9 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Range1 <a class="symbol symbol-anchor" name="findAmong" href="#findAmong">findAmong</a>(alias pred = "a == b", Range1, Range2)(Range1 <i>seq</i>, Range2 <i>choices</i>);
</h3></div>

<div class="declaration-content"><p>Advances <span class="inlinecode">seq</span> by calling <span class="inlinecode">seq.popFront</span> until either <span class="inlinecode">find!(pred)(choices, seq.front)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>, or <span class="inlinecode">seq</span> becomes
empty. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">seq.length * choices.length</span><b><i>)</i></b> evaluations of
<span class="inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/find_first_of.html">STL's
find_first_of</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
<span class="d_keyword">int</span>[] b = [ 3, 1, 2 ];
<span class="d_keyword">assert</span>(<u>findAmong</u>(a, b) == a[2 .. $]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>size_t <a class="symbol symbol-anchor" name="count" href="#count">count</a>(alias pred = "a == b", Range, E)(Range <i>r</i>, E <i>value</i>);
<br>size_t <a class="symbol symbol-anchor" name="count" href="#count">count</a>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>);
<br>size_t <a class="symbol symbol-anchor" name="count" href="#count">count</a>(alias pred = "true", Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>The first version counts the number of elements <span class="inlinecode">x</span> in <span class="inlinecode">r</span> for
which <span class="inlinecode">pred(x, value)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>. <span class="inlinecode">pred</span> defaults to
equality. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>.
</p>

<p>The second version returns the number of times <span class="inlinecode">needle</span> occurs in
<span class="inlinecode">haystack</span>. Throws an exception if <span class="inlinecode">needle.empty</span>, as the count
of the empty range in any range would be infinite. Overlapped counts
are not considered, for example <span class="inlinecode"><a class="symbol symbol-anchor" name="count" href="#count">count</a>("aaa", "aa")</span> is <span class="inlinecode">1</span>, not
<span class="inlinecode">2</span>.
<br><br>

The third version counts the elements for which <span class="inlinecode">pred(x)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// count elements in range
</span>
<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
<span class="d_keyword">assert</span>(<u>count</u>(a, 2) == 3);
<span class="d_keyword">assert</span>(<u>count</u>!(<span class="d_string">"a &gt; b"</span>)(a, 2) == 5);
<span class="d_comment">// count range in range
</span>
<span class="d_keyword">assert</span>(<u>count</u>(<span class="d_string">"abcadfabf"</span>, <span class="d_string">"ab"</span>) == 2);
<span class="d_keyword">assert</span>(<u>count</u>(<span class="d_string">"ababab"</span>, <span class="d_string">"abab"</span>) == 1);
<span class="d_keyword">assert</span>(<u>count</u>(<span class="d_string">"ababab"</span>, <span class="d_string">"abx"</span>) == 0);
<span class="d_comment">// count predicate in range
</span>
<span class="d_keyword">assert</span>(<u>count</u>!(<span class="d_string">"a &gt; 1"</span>)(a) == 8);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="balancedParens" href="#balancedParens">balancedParens</a>(Range, E)(Range <i>r</i>, E <i>lPar</i>, E <i>rPar</i>, size_t <i>maxNestingLevel</i> = size_t.max);
</h3></div>

<div class="declaration-content"><p>Checks whether <span class="inlinecode">r</span> has "balanced parentheses", i.e. all instances
of <span class="inlinecode">lPar</span> are closed by corresponding instances of <span class="inlinecode">rPar</span>. The
parameter <span class="inlinecode">maxNestingLevel</span> controls the nesting level allowed. The
most common uses are the default or <span class="inlinecode">0</span>. In the latter case, no
nesting is allowed.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> s = <span class="d_string">"1 + (2 * (3 + 1 / 2)"</span>;
<span class="d_keyword">assert</span>(!<u>balancedParens</u>(s, '(', ')'));
s = <span class="d_string">"1 + (2 * (3 + 1) / 2)"</span>;
<span class="d_keyword">assert</span>(<u>balancedParens</u>(s, '(', ')'));
s = <span class="d_string">"1 + (2 * (3 + 1) / 2)"</span>;
<span class="d_keyword">assert</span>(!<u>balancedParens</u>(s, '(', ')', 1));
s = <span class="d_string">"1 + (2 * 3 + 1) / (2 - 5)"</span>;
<span class="d_keyword">assert</span>(<u>balancedParens</u>(s, '(', ')', 1));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="equal" href="#equal">equal</a>(alias pred = "a == b", Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if the two ranges compare <a class="symbol symbol-anchor" name="equal" href="#equal">equal</a> element
for element, according to binary predicate <span class="inlinecode">pred</span>. The ranges may
have different element types, as long as <span class="inlinecode">pred(a, b)</span> evaluates to
<span class="inlinecode">bool</span> for <span class="inlinecode">a</span> in <span class="inlinecode">r1</span> and <span class="inlinecode">b</span> in <span class="inlinecode">r2</span>. Performs
<b><i>&Omicron;</i>(</b><span class="inlinecode">min(r1.length, r2.length)</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>. See also
<a href="http://sgi.com/tech/stl/equal.html">STL's equal</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 3 ];
<span class="d_keyword">assert</span>(!<u>equal</u>(a, a[1..$]));
<span class="d_keyword">assert</span>(<u>equal</u>(a, a));

<span class="d_comment">// different types
</span>
<span class="d_keyword">double</span>[] b = [ 1., 2, 4, 3];
<span class="d_keyword">assert</span>(!<u>equal</u>(a, b[1..$]));
<span class="d_keyword">assert</span>(<u>equal</u>(a, b));

<span class="d_comment">// predicated: ensure that two vectors are approximately equal
</span>
<span class="d_keyword">double</span>[] c = [ 1.005, 2, 4, 3];
<span class="d_keyword">assert</span>(<u>equal</u>!(approxEqual)(b, c));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>int <a class="symbol symbol-anchor" name="cmp" href="#cmp">cmp</a>(alias pred = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Performs three-way lexicographical comparison on two input ranges
according to predicate <span class="inlinecode">pred</span>. Iterating <span class="inlinecode">r1</span> and <span class="inlinecode">r2</span> in
lockstep, <span class="inlinecode"><a class="symbol symbol-anchor" name="cmp" href="#cmp">cmp</a></span> compares each element <span class="inlinecode">e1</span> of <span class="inlinecode">r1</span> with the
corresponding element <span class="inlinecode">e2</span> in <span class="inlinecode">r2</span>. If <span class="inlinecode">binaryFun!pred(e1,
e2)</span>, <span class="inlinecode"><a class="symbol symbol-anchor" name="cmp" href="#cmp">cmp</a></span> returns a negative value. If <span class="inlinecode">binaryFun!pred(e2,
e1)</span>, <span class="inlinecode"><a class="symbol symbol-anchor" name="cmp" href="#cmp">cmp</a></span> returns a positive value. If one of the ranges has been
finished, <span class="inlinecode"><a class="symbol symbol-anchor" name="cmp" href="#cmp">cmp</a></span> returns a negative value if <span class="inlinecode">r1</span> has fewer
elements than <span class="inlinecode">r2</span>, a positive value if <span class="inlinecode">r1</span> has more elements
than <span class="inlinecode">r2</span>, and <span class="inlinecode">0</span> if the ranges have the same number of
elements.
</p>

<p>If the ranges are strings, <span class="inlinecode"><a class="symbol symbol-anchor" name="cmp" href="#cmp">cmp</a></span> performs UTF decoding
appropriately and compares the ranges one code point at a time.</p>

</div>

<hr><div class="row-fluid declaration"><h3>MinType!(T1,T2,T) <a class="symbol symbol-anchor" name="min" href="#min">min</a>(T1, T2, T...)(T1 <i>a</i>, T2 <i>b</i>, T <i>xs</i>);
</h3></div>

<div class="declaration-content"><p>Returns the minimum of the passed-in values. The type of the result is
computed by using <a href="std_traits.html#CommonType"><span class="inlinecode">std.traits.CommonType</span></a>.</p>


</div>

<hr><div class="row-fluid declaration"><h3>MaxType!(T1,T2,T) <a class="symbol symbol-anchor" name="max" href="#max">max</a>(T1, T2, T...)(T1 <i>a</i>, T2 <i>b</i>, T <i>xs</i>);
</h3></div>

<div class="declaration-content"><p>Returns the maximum of the passed-in values. The type of the result is
computed by using <a href="std_traits.html#CommonType"><span class="inlinecode">std.traits.CommonType</span></a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span> a = 5;
<span class="d_keyword">short</span> b = 6;
<span class="d_keyword">double</span> c = 2;
<span class="d_keyword">auto</span> d = <u>max</u>(a, b);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(d) == <span class="d_keyword">int</span>));
<span class="d_keyword">assert</span>(d == 6);
<span class="d_keyword">auto</span> e = min(a, b, c);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(e) == <span class="d_keyword">double</span>));
<span class="d_keyword">assert</span>(e == 2);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Tuple!(ElementType!(Range),size_t) <a class="symbol symbol-anchor" name="minCount" href="#minCount">minCount</a>(alias pred = "a &lt; b", Range)(Range <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Returns the minimum element of a range together with the number of
occurrences. The function can actually be used for counting the
maximum or any other ordering predicate (that's why <span class="inlinecode">maxCount</span> is
not provided).
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
<span class="d_comment">// Minimum is 1 and occurs 3 times
</span>
<span class="d_keyword">assert</span>(<u>minCount</u>(a) == tuple(1, 3));
<span class="d_comment">// Maximum is 4 and occurs 2 times
</span>
<span class="d_keyword">assert</span>(<u>minCount</u>!(<span class="d_string">"a &gt; b"</span>)(a) == tuple(4, 2));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Range <a class="symbol symbol-anchor" name="minPos" href="#minPos">minPos</a>(alias pred = "a &lt; b", Range)(Range <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Returns the position of the minimum element of forward range <span class="inlinecode">range</span>, i.e. a subrange of <span class="inlinecode">range</span> starting at the position of its
smallest element and with the same ending as <span class="inlinecode">range</span>. The function
can actually be used for counting the maximum or any other ordering
predicate (that's why <span class="inlinecode">maxPos</span> is not provided).
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
<span class="d_comment">// Minimum is 1 and first occurs in position 3
</span>
<span class="d_keyword">assert</span>(<u>minPos</u>(a) == [ 1, 2, 4, 1, 1, 2 ]);
<span class="d_comment">// Maximum is 4 and first occurs in position 2
</span>
<span class="d_keyword">assert</span>(<u>minPos</u>!(<span class="d_string">"a &gt; b"</span>)(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Tuple!(Range1,Range2) <a class="symbol symbol-anchor" name="mismatch" href="#mismatch">mismatch</a>(alias pred = "a == b", Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Sequentially compares elements in <span class="inlinecode">r1</span> and <span class="inlinecode">r2</span> in lockstep, and
stops at the first <a class="symbol symbol-anchor" name="mismatch" href="#mismatch">mismatch</a> (according to <span class="inlinecode">pred</span>, by default
equality). Returns a tuple with the reduced ranges that start with the
two mismatched values. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">min(r1.length, r2.length)</span><b><i>)</i></b>
evaluations of <span class="inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/mismatch.html">STL's mismatch</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[]    x = [ 1,  5, 2, 7,   4, 3 ];
<span class="d_keyword">double</span>[] y = [ 1., 5, 2, 7.3, 4, 8 ];
<span class="d_keyword">auto</span> m = <u>mismatch</u>(x, y);
<span class="d_keyword">assert</span>(m[0] == x[3 .. $]);
<span class="d_keyword">assert</span>(m[1] == y[3 .. $]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>enum <a class="symbol symbol-anchor" name="EditOp" href="#EditOp">EditOp</a>;
</h3></div>

<div class="declaration-content"><p>Encodes <a href="http://realityinteractive.com/rgrzywinski/archives/000249.html">edit operations</a> necessary to transform one sequence into
another. Given sequences <span class="inlinecode">s</span> (source) and <span class="inlinecode">t</span> (target), a
sequence of <span class="inlinecode"><a class="symbol symbol-anchor" name="EditOp" href="#EditOp">EditOp</a></span> encodes the steps that need to be taken to
convert <span class="inlinecode">s</span> into <span class="inlinecode">t</span>. For example, if <span class="inlinecode">s = "cat"</span> and <span class="inlinecode">"cars"</span>, the minimal sequence that transforms <span class="inlinecode">s</span> into <span class="inlinecode">t</span> is:
skip two characters, replace 't' with 'r', and insert an 's'. Working
with edit operations is useful in applications such as spell-checkers
(to find the closest word to a given misspelled word), approximate
searches, diff-style programs that compute the difference between
files, efficient encoding of patches, DNA sequence analysis, and
plagiarism detection.</p>


<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="none" href="#none">none</a></h3></div>

<div class="declaration-content"><p>Current items are equal; no editing is necessary. </p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="substitute" href="#substitute">substitute</a></h3></div>

<div class="declaration-content"><p>Substitute current item in target with current item in source. </p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="insert" href="#insert">insert</a></h3></div>

<div class="declaration-content"><p>Insert current item from the source into the target. </p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="remove" href="#remove">remove</a></h3></div>

<div class="declaration-content"><p>Remove current item from the target. </p>


</div>

</div>

</div>

<hr><div class="row-fluid declaration"><h3>size_t <a class="symbol symbol-anchor" name="levenshteinDistance" href="#levenshteinDistance">levenshteinDistance</a>(alias equals = "a == b", Range1, Range2)(Range1 <i>s</i>, Range2 <i>t</i>);
</h3></div>

<div class="declaration-content"><p>Returns the <a href="http://wikipedia.org/wiki/Levenshtein_distance">Levenshtein
distance</a> between <span class="inlinecode">s</span> and <span class="inlinecode">t</span>. The Levenshtein distance computes
the minimal amount of edit operations necessary to transform <span class="inlinecode">s</span>
into <span class="inlinecode">t</span>.  Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">s.length * t.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">equals</span> and occupies <b><i>&Omicron;</i>(</b><span class="inlinecode">s.length * t.length</span><b><i>)</i></b> storage.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<u>levenshteinDistance</u>(<span class="d_string">"cat"</span>, <span class="d_string">"rat"</span>) == 1);
<span class="d_keyword">assert</span>(<u>levenshteinDistance</u>(<span class="d_string">"parks"</span>, <span class="d_string">"spark"</span>) == 2);
<span class="d_keyword">assert</span>(<u>levenshteinDistance</u>(<span class="d_string">"kitten"</span>, <span class="d_string">"sitting"</span>) == 3);
<span class="d_comment">// ignore case
</span>
<span class="d_keyword">assert</span>(<u>levenshteinDistance</u>!(<span class="d_string">"std.uni.toUpper(a) == std.uni.toUpper(b)"</span>)
    (<span class="d_string">"parks"</span>, <span class="d_string">"SPARK"</span>) == 2);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Tuple!(size_t,EditOp[]) <a class="symbol symbol-anchor" name="levenshteinDistanceAndPath" href="#levenshteinDistanceAndPath">levenshteinDistanceAndPath</a>(alias equals = "a == b", Range1, Range2)(Range1 <i>s</i>, Range2 <i>t</i>);
</h3></div>

<div class="declaration-content"><p>Returns the Levenshtein distance and the edit path between <span class="inlinecode">s</span> and
<span class="inlinecode">t</span>.
</p>

<b>Example:</b><br>
<pre class="d_code">string a = <span class="d_string">"Saturday"</span>, b = <span class="d_string">"Sunday"</span>;
<span class="d_keyword">auto</span> p = <u>levenshteinDistanceAndPath</u>(a, b);
<span class="d_keyword">assert</span>(p[0] == 3);
<span class="d_keyword">assert</span>(equal(p[1], <span class="d_string">"nrrnsnnn"</span>));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Range2 <a class="symbol symbol-anchor" name="copy" href="#copy">copy</a>(Range1, Range2)(Range1 <i>source</i>, Range2 <i>target</i>);
</h3></div>

<div class="declaration-content"><p>Copies the content of <span class="inlinecode">source</span> into <span class="inlinecode">target</span> and returns the
remaining (unfilled) part of <span class="inlinecode">target</span>. See also <a href="http://sgi.com/tech/stl/copy.html">STL's copy</a>. If a behavior similar to
<a href="http://sgi.com/tech/stl/copy_backward.html">STL's copy_backward</a> is
needed, use <span class="inlinecode"><a class="symbol symbol-anchor" name="copy" href="#copy">copy</a>(retro(source), retro(target))</span>. See also <a href="std_range.html#retro"><span class="inlinecode">std.range.retro</span></a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 5 ];
<span class="d_keyword">int</span>[] b = [ 9, 8 ];
<span class="d_keyword">int</span>[] c = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[a.length + b.length + 10];
<span class="d_keyword">auto</span> d = <u>copy</u>(b, <u>copy</u>(a, c));
<span class="d_keyword">assert</span>(c[0 .. a.length + b.length] == a ~ b);
<span class="d_keyword">assert</span>(d.length == 10);
</pre>

As long as the target range elements support assignment from source
range elements, different types of ranges are accepted.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">float</span>[] a = [ 1.0f, 5 ];
<span class="d_keyword">double</span>[] b = <span class="d_keyword">new</span> <span class="d_keyword">double</span>[a.length];
<span class="d_keyword">auto</span> d = <u>copy</u>(a, b);
</pre>

To <a class="symbol symbol-anchor" name="copy" href="#copy">copy</a> at most <span class="inlinecode">n</span> elements from range <span class="inlinecode">a</span> to range <span class="inlinecode">b</span>, you
may want to use <span class="inlinecode"><a class="symbol symbol-anchor" name="copy" href="#copy">copy</a>(take(a, n), b)</span>. To <a class="symbol symbol-anchor" name="copy" href="#copy">copy</a> those elements from
range <span class="inlinecode">a</span> that satisfy predicate <span class="inlinecode">pred</span> to range <span class="inlinecode">b</span>, you may
want to use <span class="inlinecode"><a class="symbol symbol-anchor" name="copy" href="#copy">copy</a>(filter!(pred)(a), b)</span>.

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[a.length];
<span class="d_keyword">auto</span> c = <u>copy</u>(filter!(<span class="d_string">"(a &amp; 1) == 1"</span>)(a), b);
<span class="d_keyword">assert</span>(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Tuple!(Range1,Range2) <a class="symbol symbol-anchor" name="swapRanges" href="#swapRanges">swapRanges</a>(Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Swaps all elements of <span class="inlinecode">r1</span> with successive elements in <span class="inlinecode">r2</span>.
Returns a tuple containing the remainder portions of <span class="inlinecode">r1</span> and <span class="inlinecode">r2</span> that were not swapped (one of them will be empty). The ranges may
be of different types but must have the same element type and support
swapping.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 100, 101, 102, 103 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 3 ];
<span class="d_keyword">auto</span> c = <u>swapRanges</u>(a[1 .. 3], b[2 .. 4]);
<span class="d_keyword">assert</span>(c[0].empty &amp;&amp; c[1].empty);
<span class="d_keyword">assert</span>(a == [ 100, 2, 3, 103 ]);
<span class="d_keyword">assert</span>(b == [ 0, 1, 101, 102 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="reverse" href="#reverse">reverse</a>(Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Reverses <span class="inlinecode">r</span> in-place.  Performs <span class="inlinecode">r.length / 2</span> evaluations of <span class="inlinecode">swap</span>. See also <a href="http://sgi.com/tech/stl/reverse.html">STL's reverse</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3 ];
<u>reverse</u>(arr);
<span class="d_keyword">assert</span>(arr == [ 3, 2, 1 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="reverse" href="#reverse">reverse</a>(Char)(Char[] <i>s</i>);
</h3></div>

<div class="declaration-content"><p>Reverses <span class="inlinecode">r</span> in-place, where <span class="inlinecode">r</span> is a narrow string (having
elements of type <span class="inlinecode">char</span> or <span class="inlinecode">wchar</span>). UTF sequences consisting of
multiple code units are preserved properly.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">char</span>[] arr = <span class="d_string">"hello\U00010143\u0100\U00010143"</span>.dup;
<u>reverse</u>(arr);
<span class="d_keyword">assert</span>(arr == <span class="d_string">"\U00010143\u0100\U00010143olleh"</span>);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>size_t <a class="symbol symbol-anchor" name="bringToFront" href="#bringToFront">bringToFront</a>(Range1, Range2)(Range1 <i>front</i>, Range2 <i>back</i>);
</h3></div>

<div class="declaration-content"><p>The <span class="inlinecode"><a class="symbol symbol-anchor" name="bringToFront" href="#bringToFront">bringToFront</a></span> function has considerable flexibility and
usefulness. It can rotate elements in one buffer left or right, swap
buffers of equal length, and even move elements across disjoint
buffers of different types and different lengths.
</p>

<p><span class="inlinecode"><a class="symbol symbol-anchor" name="bringToFront" href="#bringToFront">bringToFront</a></span> takes two ranges <span class="inlinecode">front</span> and <span class="inlinecode">back</span>, which may
be of different types. Considering the concatenation of <span class="inlinecode">front</span> and
<span class="inlinecode">back</span> one unified range, <span class="inlinecode"><a class="symbol symbol-anchor" name="bringToFront" href="#bringToFront">bringToFront</a></span> rotates that unified
range such that all elements in <span class="inlinecode">back</span> are brought to the beginning
of the unified range. The relative ordering of elements in <span class="inlinecode">front</span>
and <span class="inlinecode">back</span>, respectively, remains unchanged.
<br><br>

The simplest use of <span class="inlinecode"><a class="symbol symbol-anchor" name="bringToFront" href="#bringToFront">bringToFront</a></span> is for rotating elements in a
buffer. For example:
<br><br>

<pre class="d_code"><span class="d_keyword">auto</span> arr = [4, 5, 6, 7, 1, 2, 3];
<u>bringToFront</u>(arr[0 .. 4], arr[4 .. $]);
<span class="d_keyword">assert</span>(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
</pre>

The <span class="inlinecode">front</span> range may actually "step over" the <span class="inlinecode">back</span>
range. This is very useful with forward ranges that cannot compute
comfortably right-bounded subranges like <span class="inlinecode">arr[0 .. 4]</span> above. In
the example below, <span class="inlinecode">r2</span> is a right subrange of <span class="inlinecode">r1</span>.
<br><br>

<pre class="d_code"><span class="d_keyword">auto</span> list = SList!(<span class="d_keyword">int</span>)(4, 5, 6, 7, 1, 2, 3);
<span class="d_keyword">auto</span> r1 = list[];
<span class="d_keyword">auto</span> r2 = list[]; popFrontN(r2, 4);
<span class="d_keyword">assert</span>(equal(r2, [ 1, 2, 3 ]));
<u>bringToFront</u>(r1, r2);
<span class="d_keyword">assert</span>(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));
</pre>

Elements can be swapped across ranges of different types:
<br><br>

<pre class="d_code"><span class="d_keyword">auto</span> list = SList!(<span class="d_keyword">int</span>)(4, 5, 6, 7);
<span class="d_keyword">auto</span> vec = [ 1, 2, 3 ];
<u>bringToFront</u>(list[], vec);
<span class="d_keyword">assert</span>(equal(list[], [ 1, 2, 3, 4 ]));
<span class="d_keyword">assert</span>(equal(vec, [ 5, 6, 7 ]));
</pre>

Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">max(front.length, back.length)</span><b><i>)</i></b> evaluations of <span class="inlinecode">swap</span>. See also <a href="http://sgi.com/tech/stl/rotate.html">STL's rotate</a>.

</p>
<b>Preconditions:</b><br>
Either <span class="inlinecode">front</span> and <span class="inlinecode">back</span> are disjoint, or <span class="inlinecode">back</span> is
reachable from <span class="inlinecode">front</span> and <span class="inlinecode">front</span> is not reachable from <span class="inlinecode">back</span>.

<br><br>
<div><b>Returns</b>:<br/> &nbsp; &nbsp; &nbsp; The number of elements brought to the front, i.e., the length of <span class="inlinecode">back</span>.</div>

</div>

<hr><div class="row-fluid declaration"><h3>enum <a class="symbol symbol-anchor" name="SwapStrategy" href="#SwapStrategy">SwapStrategy</a>;
</h3></div>

<div class="declaration-content"><p>Defines the swapping strategy for algorithms that need to swap
elements in a range (such as partition and sort). The strategy
concerns the swapping of elements that are not the core concern of the
algorithm. For example, consider an algorithm that sorts <span class="inlinecode">[ "abc",
"b", "aBc" ]</span> according to <span class="inlinecode">toUpper(a) &lt; toUpper(b)</span>. That
algorithm might choose to swap the two equivalent strings <span class="inlinecode">"abc"</span>
and <span class="inlinecode">"aBc"</span>. That does not affect the sorting since both <span class="inlinecode">[
"abc", "aBc", "b" ]</span> and <span class="inlinecode">[ "aBc", "abc", "b" ]</span> are valid
outcomes.
</p>

<p>Some situations require that the algorithm must NOT ever change the
relative ordering of equivalent elements (in the example above, only
<span class="inlinecode">[ "abc", "aBc", "b" ]</span> would be the correct result). Such
algorithms are called <b>stable</b>. If the ordering algorithm may swap
equivalent elements discretionarily, the ordering is called <b>unstable</b>.
<br><br>

Yet another class of algorithms may choose an intermediate tradeoff by
being stable only on a well-defined subrange of the range. There is no
established terminology for such behavior; this library calls it <b>semistable</b>.
<br><br>

Generally, the <span class="inlinecode">stable</span> ordering strategy may be more costly in
time and/or space than the other two because it imposes additional
constraints. Similarly, <span class="inlinecode">semistable</span> may be costlier than <span class="inlinecode">unstable</span>. As (semi-)stability is not needed very often, the ordering
algorithms in this module parameterized by <span class="inlinecode"><a class="symbol symbol-anchor" name="SwapStrategy" href="#SwapStrategy">SwapStrategy</a></span> all
choose <span class="inlinecode"><a class="symbol symbol-anchor" name="SwapStrategy" href="#SwapStrategy">SwapStrategy</a>.unstable</span> as the default.</p>

<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="unstable" href="#unstable">unstable</a></h3></div>

<div class="declaration-content"><p>Allows freely swapping of elements as long as the output
       satisfies the algorithm's requirements.</p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="semistable" href="#semistable">semistable</a></h3></div>

<div class="declaration-content"><p>In algorithms partitioning ranges in two, preserve relative
       ordering of elements only to the left of the partition point.</p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="stable" href="#stable">stable</a></h3></div>

<div class="declaration-content"><p>Preserve the relative ordering of elements to the largest
       extent allowed by the algorithm's requirements.</p>


</div>

</div>

</div>

<hr><div class="row-fluid declaration"><h3>Range <a class="symbol symbol-anchor" name="remove" href="#remove">remove</a>(SwapStrategy s = SwapStrategy.stable, Range, Offset...)(Range <i>range</i>, Offset <i>offset</i>);
</h3></div>

<div class="declaration-content"><p>Eliminates elements at given offsets from <span class="inlinecode">range</span> and returns the
shortened range. In the simplest call, one element is removed.
</p>

<p><pre class="d_code"><span class="d_keyword">int</span>[] a = [ 3, 5, 7, 8 ];
<span class="d_keyword">assert</span>(<u>remove</u>(a, 1) == [ 3, 7, 8 ]);
<span class="d_keyword">assert</span>(a == [ 3, 7, 8, 8 ]);
</pre>

In the case above the element at offset <span class="inlinecode">1</span> is removed and <span class="inlinecode"><a class="symbol symbol-anchor" name="remove" href="#remove">remove</a></span> returns the range smaller by one element. The original array
has remained of the same length because all functions in <span class="inlinecode">std.algorithm</span> only change <i>content</i>, not <i>topology</i>. The value
<span class="inlinecode">8</span> is repeated because <a href="std_algorithm.html#move"><span class="inlinecode">std.algorithm.move</span></a> was invoked to move
elements around and on integers <span class="inlinecode">move</span> simply copies the source to
the destination. To replace <span class="inlinecode">a</span> with the effect of the removal,
simply assign <span class="inlinecode">a = <a class="symbol symbol-anchor" name="remove" href="#remove">remove</a>(a, 1)</span>. The slice will be rebound to the
shorter array and the operation completes with maximal efficiency.
<br><br>

Multiple indices can be passed into <span class="inlinecode"><a class="symbol symbol-anchor" name="remove" href="#remove">remove</a></span>. In that case,
elements at the respective indices are all removed. The indices must
be passed in increasing order, otherwise an exception occurs.
<br><br>

<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">assert</span>(<u>remove</u>(a, 1, 3, 5) ==
    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);
</pre>

(Note how all indices refer to slots in the <i>original</i> array, not
in the array as it is being progressively shortened.) Finally, any
combination of integral offsets and tuples composed of two integral
offsets can be passed in.
<br><br>

<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">assert</span>(<u>remove</u>(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);
</pre>

In this case, the slots at positions 1, 3, 4, and 9 are removed from
the array. The tuple passes in a range closed to the left and open to
the right (consistent with built-in slices), e.g. <span class="inlinecode">tuple(3, 5)</span>
means indices <span class="inlinecode">3</span> and <span class="inlinecode">4</span> but not <span class="inlinecode">5</span>.
<br><br>

If the need is to <a class="symbol symbol-anchor" name="remove" href="#remove">remove</a> some elements in the range but the order of
the remaining elements does not have to be preserved, you may want to
pass <span class="inlinecode">SwapStrategy.unstable</span> to <span class="inlinecode"><a class="symbol symbol-anchor" name="remove" href="#remove">remove</a></span>.
<br><br>

<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3 ];
<span class="d_keyword">assert</span>(<u>remove</u>!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);
</pre>

In the case above, the element at slot <span class="inlinecode">1</span> is removed, but replaced
with the last element of the range. Taking advantage of the relaxation
of the stability requirement, <span class="inlinecode"><a class="symbol symbol-anchor" name="remove" href="#remove">remove</a></span> moved elements from the end
of the array over the slots to be removed. This way there is less data
movement to be done which improves the execution time of the function.
<br><br>

The function <span class="inlinecode"><a class="symbol symbol-anchor" name="remove" href="#remove">remove</a></span> works on any forward range. The moving
strategy is (listed from fastest to slowest): <ul><li>If <span class="inlinecode">s ==
SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp;
hasLength!Range</span>, then elements are moved from the end of the range
into the slots to be filled. In this case, the absolute minimum of
moves is performed.</li>  <li>Otherwise, if <span class="inlinecode">s ==
SwapStrategy.unstable &amp;&amp; isBidirectionalRange!Range &amp;&amp;
hasLength!Range</span>, then elements are still moved from the end of the
range, but time is spent on advancing between slots by repeated calls
to <span class="inlinecode">range.popFront</span>.</li>  <li>Otherwise, elements are moved incrementally
towards the front of <span class="inlinecode">range</span>; a given element is never moved
several times, but more elements are moved than in the previous
cases.</li></ul></p>

</div>

<hr><div class="row-fluid declaration"><h3>Range <a class="symbol symbol-anchor" name="remove" href="#remove">remove</a>(alias pred, SwapStrategy s = SwapStrategy.stable, Range)(Range <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Reduces the length of the bidirectional range <span class="inlinecode">range</span> by removing
elements that satisfy <span class="inlinecode">pred</span>. If <span class="inlinecode">s = SwapStrategy.unstable</span>,
elements are moved from the right end of the range over the elements
to eliminate. If <span class="inlinecode">s = SwapStrategy.stable</span> (the default),
elements are moved progressively to front such that their relative
order is preserved. Returns the filtered range.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];
<span class="d_keyword">assert</span>(<u>remove</u>!(<span class="d_string">"a == 2"</span>)(a) == [ 1, 3, 3, 4, 5, 5, 6 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>Range <a class="symbol symbol-anchor" name="partition" href="#partition">partition</a>(alias predicate, SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Partitions a range in two using <span class="inlinecode">pred</span> as a
predicate. Specifically, reorders the range <span class="inlinecode">r = [left,
right)</span> using <span class="inlinecode">swap</span> such that all elements <span class="inlinecode">i</span> for
which <span class="inlinecode">pred(i)</span> is <span class="inlinecode"><span class="d_keyword">true</span></span> come before all elements <span class="inlinecode">j</span> for
which <span class="inlinecode">pred(j)</span> returns <span class="inlinecode"><span class="d_keyword">false</span></span>.
</p>

<p>Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> (if unstable or semistable) or <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length * log(r.length)</span><b><i>)</i></b> (if stable) evaluations of <span class="inlinecode">less</span> and <span class="inlinecode">swap</span>. The unstable version computes the minimum possible evaluations
of <span class="inlinecode">swap</span> (roughly half of those performed by the semistable
version).
<br><br>

See also STL's <a href="http://sgi.com/tech/stl/partition.html">partition</a> and
<a href="http://sgi.com/tech/stl/stable_partition.html">stable_partition</a>.

</p>
<div><b>Returns</b>:<br/> &nbsp; &nbsp; &nbsp; The right part of <span class="inlinecode">r</span> after partitioning.
<br><br>

If <span class="inlinecode">ss == SwapStrategy.stable</span>, <span class="inlinecode"><a class="symbol symbol-anchor" name="partition" href="#partition">partition</a></span> preserves the
relative ordering of all elements <span class="inlinecode">a</span>, <span class="inlinecode">b</span> in <span class="inlinecode">r</span> for which
<span class="inlinecode">pred(a) == pred(b)</span>. If <span class="inlinecode">ss == SwapStrategy.semistable</span>, <span class="inlinecode"><a class="symbol symbol-anchor" name="partition" href="#partition">partition</a></span> preserves the relative ordering of all elements <span class="inlinecode">a</span>, <span class="inlinecode">b</span> in the left part of <span class="inlinecode">r</span> for which <span class="inlinecode">pred(a) == pred(b)</span>.

</div>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
<span class="d_keyword">auto</span> arr = Arr.dup;
<span class="d_keyword">static</span> <span class="d_keyword">bool</span> even(<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> (a &amp; 1) == 0; }
<span class="d_comment">// Partition arr such that even numbers come first
</span>
<span class="d_keyword">auto</span> r = <u>partition</u>!(even)(arr);
<span class="d_comment">// Now arr is separated in evens and odds.
</span>
<span class="d_comment">// Numbers may have become shuffled due to instability
</span>
<span class="d_keyword">assert</span>(r == arr[5 .. $]);
<span class="d_keyword">assert</span>(count!(even)(arr[0 .. 5]) == 5);
<span class="d_keyword">assert</span>(find!(even)(r).empty);

<span class="d_comment">// Can also specify the predicate as a string.
</span>
<span class="d_comment">// Use 'a' as the predicate argument name
</span>
arr[] = Arr[];
r = <u>partition</u>!(<span class="d_string">q{(a &amp; 1) == 0}</span>)(arr);
<span class="d_keyword">assert</span>(r == arr[5 .. $]);

<span class="d_comment">// Now for a stable partition:
</span>
arr[] = Arr[];
r = <u>partition</u>!(<span class="d_string">q{(a &amp; 1) == 0}</span>, SwapStrategy.stable)(arr);
<span class="d_comment">// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1
</span>
<span class="d_keyword">assert</span>(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] &amp;&amp; r == arr[5 .. $]);

<span class="d_comment">// In case the predicate needs to hold its own state, use a delegate:
</span>
arr[] = Arr[];
<span class="d_keyword">int</span> x = 3;
<span class="d_comment">// Put stuff greater than 3 on the left
</span>
<span class="d_keyword">bool</span> fun(<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> a &gt; x; }
r = <u>partition</u>!(fun, SwapStrategy.semistable)(arr);
<span class="d_comment">// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2
</span>
<span class="d_keyword">assert</span>(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] &amp;&amp; r == arr[7 .. $]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="isPartitioned" href="#isPartitioned">isPartitioned</a>(alias pred, Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if <span class="inlinecode">r</span> is partitioned according to predicate <span class="inlinecode">pred</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] r = [ 1, 3, 5, 7, 8, 2, 4, ];
<span class="d_keyword">assert</span>(<u>isPartitioned</u>!(<span class="d_string">"a &amp; 1"</span>)(r));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>auto <a class="symbol symbol-anchor" name="partition3" href="#partition3">partition3</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, E)(Range <i>r</i>, E <i>pivot</i>);
</h3></div>

<div class="declaration-content"><p>Rearranges elements in <span class="inlinecode">r</span> in three adjacent ranges and returns
them. The first and leftmost range only contains elements in <span class="inlinecode">r</span>
less than <span class="inlinecode">pivot</span>. The second and middle range only contains
elements in <span class="inlinecode">r</span> that are equal to <span class="inlinecode">pivot</span>. Finally, the third
and rightmost range only contains elements in <span class="inlinecode">r</span> that are greater
than <span class="inlinecode">pivot</span>. The less-than test is defined by the binary function
<span class="inlinecode">less</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = [ 8, 3, 4, 1, 4, 7, 4 ];
<span class="d_keyword">auto</span> pieces = <u>partition3</u>(a, 4);
<span class="d_keyword">assert</span>(a == [ 1, 3, 4, 4, 4, 7, 8 ];
<span class="d_keyword">assert</span>(pieces[0] == [ 1, 3 ]);
<span class="d_keyword">assert</span>(pieces[1] == [ 4, 4, 4 ]);
<span class="d_keyword">assert</span>(pieces[2] == [ 7, 8 ]);
</pre>

<br><br>
<div><b>Known bugs</b>:<br/> &nbsp; &nbsp; &nbsp; stable <span class="inlinecode"><a class="symbol symbol-anchor" name="partition3" href="#partition3">partition3</a></span> has not been implemented yet.</div>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="topN" href="#topN">topN</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>, size_t <i>nth</i>);
</h3></div>

<div class="declaration-content"><p>Reorders the range <span class="inlinecode">r</span> using <span class="inlinecode">swap</span> such that <span class="inlinecode">r[nth]</span> refers
to the element that would fall there if the range were fully
sorted. In addition, it also partitions <span class="inlinecode">r</span> such that all elements
<span class="inlinecode">e1</span> from <span class="inlinecode">r[0]</span> to <span class="inlinecode">r[nth]</span> satisfy <span class="inlinecode">!less(r[nth], e1)</span>,
and all elements <span class="inlinecode">e2</span> from <span class="inlinecode">r[nth]</span> to <span class="inlinecode">r[r.length]</span> satisfy
<span class="inlinecode">!less(e2, r[nth])</span>. Effectively, it finds the nth smallest
(according to <span class="inlinecode">less</span>) elements in <span class="inlinecode">r</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> (if unstable) or <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length * log(r.length)</span><b><i>)</i></b> (if
stable) evaluations of <span class="inlinecode">less</span> and <span class="inlinecode">swap</span>. See also <a href="http://sgi.com/tech/stl/nth_element.html">STL's nth_element</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] v = [ 25, 7, 9, 2, 0, 5, 21 ];
<span class="d_keyword">auto</span> n = 4;
<u>topN</u>!(less)(v, n);
<span class="d_keyword">assert</span>(v[n] == 9);
<span class="d_comment">// Equivalent form:
</span>
<u>topN</u>!(<span class="d_string">"a &lt; b"</span>)(v, n);
<span class="d_keyword">assert</span>(v[n] == 9);
</pre>

<br><br>
<div><b>Known bugs</b>:<br/> &nbsp; &nbsp; &nbsp; Stable <a class="symbol symbol-anchor" name="topN" href="#topN">topN</a> has not been implemented yet.</div>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="topN" href="#topN">topN</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Stores the smallest elements of the two ranges in the left-hand range.</p>


</div>

<hr><div class="row-fluid declaration"><h3>SortedRange!(Range,less) <a class="symbol symbol-anchor" name="sort" href="#sort">sort</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Sorts a random-access range according to predicate <span class="inlinecode">less</span>. Performs
<b><i>&Omicron;</i>(</b><span class="inlinecode">r.length * log(r.length)</span><b><i>)</i></b> (if unstable) or <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length *
log(r.length) * log(r.length)</span><b><i>)</i></b> (if stable) evaluations of <span class="inlinecode">less</span>
and <span class="inlinecode">swap</span>. See also STL's <a href="http://sgi.com/tech/stl/sort.html">sort</a>
and <a href="http://sgi.com/tech/stl/stable_sort.html">stable_sort</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] array = [ 1, 2, 3, 4 ];
<span class="d_comment">// sort in descending order
</span>
<u>sort</u>!(<span class="d_string">"a &gt; b"</span>)(array);
<span class="d_keyword">assert</span>(array == [ 4, 3, 2, 1 ]);
<span class="d_comment">// sort in ascending order
</span>
<u>sort</u>(array);
<span class="d_keyword">assert</span>(array == [ 1, 2, 3, 4 ]);
<span class="d_comment">// sort with a delegate
</span>
<span class="d_keyword">bool</span> myComp(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> x &gt; y; }
<u>sort</u>!(myComp)(array);
<span class="d_keyword">assert</span>(array == [ 4, 3, 2, 1 ]);
<span class="d_comment">// Showcase stable sorting
</span>
string[] words = [ <span class="d_string">"aBc"</span>, <span class="d_string">"a"</span>, <span class="d_string">"abc"</span>, <span class="d_string">"b"</span>, <span class="d_string">"ABC"</span>, <span class="d_string">"c"</span> ];
<u>sort</u>!(<span class="d_string">"toUpper(a) &lt; toUpper(b)"</span>, SwapStrategy.stable)(words);
<span class="d_keyword">assert</span>(words == [ <span class="d_string">"a"</span>, <span class="d_string">"aBc"</span>, <span class="d_string">"abc"</span>, <span class="d_string">"ABC"</span>, <span class="d_string">"b"</span>, <span class="d_string">"c"</span> ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>template <a class="symbol symbol-anchor" name="multiSort" href="#multiSort">multiSort</a>(less...)</h3></div>

<div class="declaration-content"><p>Sorts a range by multiple keys. The call <span class="inlinecode"><a class="symbol symbol-anchor" name="multiSort" href="#multiSort">multiSort</a>!("a.id &lt; b.id",
"a.date &gt; b.date")(r)</span> sorts the range <span class="inlinecode">r</span> by <span class="inlinecode">id</span> ascending,
and sorts elements that have the same <span class="inlinecode">id</span> by <span class="inlinecode">date</span>
descending. Such a call is equivalent to <span class="inlinecode">sort!"a.id != b.id ? a.id
&lt; b.id : a.date &gt; b.date"(r)</span>, but <span class="inlinecode"><a class="symbol symbol-anchor" name="multiSort" href="#multiSort">multiSort</a></span> is faster because it
does fewer comparisons (in addition to being more convenient).
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">struct</span> Point { <span class="d_keyword">int</span> x, y; }
<span class="d_keyword">auto</span> pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];
<span class="d_keyword">auto</span> pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];
<u>multiSort</u>!(<span class="d_string">"a.x &lt; b.x"</span>, <span class="d_string">"a.y &lt; b.y"</span>, SwapStrategy.unstable)(pts1);
<span class="d_keyword">assert</span>(pts1 == pts2);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="schwartzSort" href="#schwartzSort">schwartzSort</a>(alias transform, alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Sorts a range using an algorithm akin to the <a href="http://wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>, also
known as the decorate-sort-undecorate pattern in Python and Lisp. (Not
to be confused with <a href="http://youtube.com/watch?v=S25Zf8svHZQ">the other
Schwartz</a>.) This function is helpful when the sort comparison includes
an expensive computation. The complexity is the same as that of the
corresponding <span class="inlinecode">sort</span>, but <span class="inlinecode"><a class="symbol symbol-anchor" name="schwartzSort" href="#schwartzSort">schwartzSort</a></span> evaluates <span class="inlinecode">transform</span> only <span class="inlinecode">r.length</span> times (less than half when compared to
regular sorting). The usage can be best illustrated with an example.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">uint</span> hashFun(string) { ... expensive computation ... }
string[] array = ...;
<span class="d_comment">// Sort strings by hash, slow
</span>
sort!(<span class="d_string">"hashFun(a) &lt; hashFun(b)"</span>)(array);
<span class="d_comment">// Sort strings by hash, fast (only computes arr.length hashes):
</span>
<u>schwartzSort</u>!(hashFun, <span class="d_string">"a &lt; b"</span>)(array);
</pre>

The <span class="inlinecode"><a class="symbol symbol-anchor" name="schwartzSort" href="#schwartzSort">schwartzSort</a></span> function might require less temporary data and
be faster than the Perl idiom or the decorate-sort-undecorate idiom
present in Python and Lisp. This is because sorting is done in-place
and only minimal extra data (one array of transformed elements) is
created.
<br><br>

To check whether an array was sorted and benefit of the speedup of
Schwartz sorting, a function <span class="inlinecode">schwartzIsSorted</span> is not provided
because the effect can be achieved by calling <span class="inlinecode">isSorted!less(map!transform(r))</span>.<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="partialSort" href="#partialSort">partialSort</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>, size_t <i>n</i>);
</h3></div>

<div class="declaration-content"><p>Reorders the random-access range <span class="inlinecode">r</span> such that the range <span class="inlinecode">r[0
.. mid]</span> is the same as if the entire <span class="inlinecode">r</span> were sorted, and leaves
the range <span class="inlinecode">r[mid .. r.length]</span> in no particular order. Performs
<b><i>&Omicron;</i>(</b><span class="inlinecode">r.length * log(mid)</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>. The
implementation simply calls <span class="inlinecode">topN!(less, ss)(r, n)</span> and then <span class="inlinecode">sort!(less, ss)(r[0 .. n])</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
<u>partialSort</u>(a, 5);
<span class="d_keyword">assert</span>(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="completeSort" href="#completeSort">completeSort</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(SortedRange!(Range1,less) <i>lhs</i>, Range2 <i>rhs</i>);
</h3></div>

<div class="declaration-content"><p>Sorts the random-access range <span class="inlinecode">chain(lhs, rhs)</span> according to
predicate <span class="inlinecode">less</span>. The left-hand side of the range <span class="inlinecode">lhs</span> is
assumed to be already sorted; <span class="inlinecode">rhs</span> is assumed to be unsorted. The
exact strategy chosen depends on the relative sizes of <span class="inlinecode">lhs</span> and
<span class="inlinecode">rhs</span>.  Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">lhs.length + rhs.length * log(rhs.length)</span><b><i>)</i></b>
(best case) to <b><i>&Omicron;</i>(</b><span class="inlinecode">(lhs.length + rhs.length) * log(lhs.length +
rhs.length)</span><b><i>)</i></b> (worst-case) evaluations of <span class="inlinecode">swap</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3 ];
<span class="d_keyword">int</span>[] b = [ 4, 0, 6, 5 ];
<u>completeSort</u>(assumeSorted(a), b);
<span class="d_keyword">assert</span>(a == [ 0, 1, 2 ]);
<span class="d_keyword">assert</span>(b == [ 3, 4, 5, 6 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="isSorted" href="#isSorted">isSorted</a>(alias less = "a &lt; b", Range)(Range <i>r</i>);
</h3></div>

<div class="declaration-content"><p>Checks whether a forward range is sorted according to the comparison
operation <span class="inlinecode">less</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">less</span>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [4, 3, 2, 1];
<span class="d_keyword">assert</span>(!<u>isSorted</u>(arr));
sort(arr);
<span class="d_keyword">assert</span>(<u>isSorted</u>(arr));
sort!(<span class="d_string">"a &gt; b"</span>)(arr);
<span class="d_keyword">assert</span>(<u>isSorted</u>!(<span class="d_string">"a &gt; b"</span>)(arr));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="makeIndex" href="#makeIndex">makeIndex</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range <i>r</i>, RangeIndex <i>index</i>);
<br>void <a class="symbol symbol-anchor" name="makeIndex" href="#makeIndex">makeIndex</a>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range <i>r</i>, RangeIndex <i>index</i>);
</h3></div>

<div class="declaration-content"><p>Computes an index for <span class="inlinecode">r</span> based on the comparison <span class="inlinecode">less</span>. The
index is a sorted array of pointers or indices into the original
range. This technique is similar to sorting, but it is more flexible
because (1) it allows "sorting" of immutable collections, (2) allows
binary search even if the original collection does not offer random
access, (3) allows multiple indexes, each on a different predicate,
and (4) may be faster when dealing with large objects. However, using
an index may also be slower under certain circumstances due to the
extra indirection, and is always larger than a sorting-based solution
because it needs space for the index in addition to the original
collection. The complexity is the same as <span class="inlinecode">sort</span>'s.
</p>

<p><span class="inlinecode"><a class="symbol symbol-anchor" name="makeIndex" href="#makeIndex">makeIndex</a></span> overwrites its second argument with the result, but
never reallocates it. If the second argument's length is less than
that of the range indexed, an exception is thrown.
<br><br>

The first overload of <span class="inlinecode"><a class="symbol symbol-anchor" name="makeIndex" href="#makeIndex">makeIndex</a></span> writes to a range containing
pointers, and the second writes to a range containing offsets. The
first overload requires <span class="inlinecode">Range</span> to be a forward range, and the
latter requires it to be a random-access range.

</p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>[]) arr = [ 2, 3, 1, 5, 0 ];
<span class="d_comment">// index using pointers
</span>
<span class="d_keyword">auto</span> index1 = <span class="d_keyword">new</span> <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)*[arr.length];
<u>makeIndex</u>!(<span class="d_string">"a &lt; b"</span>)(arr, index1);
<span class="d_keyword">assert</span>(isSorted!(<span class="d_string">"*a &lt; *b"</span>)(index1));
<span class="d_comment">// index using offsets
</span>
<span class="d_keyword">auto</span> index2 = <span class="d_keyword">new</span> size_t[arr.length];
<u>makeIndex</u>!(<span class="d_string">"a &lt; b"</span>)(arr, index2);
<span class="d_keyword">assert</span>(isSorted!
    ((size_t a, size_t b){ <span class="d_keyword">return</span> arr[a] &lt; arr[b];})
    (index2));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>enum <a class="symbol symbol-anchor" name="SortOutput" href="#SortOutput">SortOutput</a>;
</h3></div>

<div class="declaration-content"><p>Specifies whether the output of certain algorithm is desired in sorted
format.</p>


<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="no" href="#no">no</a></h3></div>

<div class="declaration-content"><p>Don't sort output</p>


</div>

<hr><div class="row-fluid declaration"><h3><a class="symbol symbol-anchor" name="yes" href="#yes">yes</a></h3></div>

<div class="declaration-content"><p>Sort output</p>


</div>

</div>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="canFind" href="#canFind">canFind</a>(alias pred = "a == b", Range, V)(Range <i>range</i>, V <i>value</i>);
</h3></div>

<div class="declaration-content"><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if <span class="inlinecode">value</span> can be found in <span class="inlinecode">range</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>. </p>


</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="canFind" href="#canFind">canFind</a>(alias pred, Range)(Range <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Forwards to <span class="inlinecode">any</span> for backwards compatibility.
</p>

<p><font color=red>Scheduled for deprecation in August 2012. Please use <span class="inlinecode">any</span> instead.</font></p>

</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="any" href="#any">any</a>(alias pred, Range)(Range <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if a value <span class="inlinecode">v</span> satisfying the
predicate <span class="inlinecode">pred</span> can be found in the forward range <span class="inlinecode">range</span>. Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>.</p>


</div>

<hr><div class="row-fluid declaration"><h3>bool <a class="symbol symbol-anchor" name="all" href="#all">all</a>(alias pred, R)(R <i>range</i>);
</h3></div>

<div class="declaration-content"><p>Returns <span class="inlinecode"><span class="d_keyword">true</span></span> if and only if <a class="symbol symbol-anchor" name="all" href="#all">all</a> values in <span class="inlinecode">range</span> satisfy the
predicate <span class="inlinecode">pred</span>.  Performs <b><i>&Omicron;</i>(</b><span class="inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="inlinecode">pred</span>.
</p>

<div><b>Examples</b>:<br/> &nbsp; &nbsp; &nbsp; <pre class="d_code"><span class="d_keyword">assert</span>(<u>all</u>!<span class="d_string">"a &amp; 1"</span>([1, 3, 5, 7, 9]));
<span class="d_keyword">assert</span>(!<u>all</u>!<span class="d_string">"a &amp; 1"</span>([1, 2, 3, 5, 7, 9]));
</pre>
</div>

</div>

<hr><div class="row-fluid declaration"><h3>TRange <a class="symbol symbol-anchor" name="topNCopy" href="#topNCopy">topNCopy</a>(alias less = "a &lt; b", SRange, TRange)(SRange <i>source</i>, TRange <i>target</i>, SortOutput <i>sorted</i> = SortOutput.no);
</h3></div>

<div class="declaration-content"><p>Copies the top <span class="inlinecode">n</span> elements of the input range <span class="inlinecode">source</span> into the
random-access range <span class="inlinecode">target</span>, where <span class="inlinecode">n =
target.length</span>. Elements of <span class="inlinecode">source</span> are not touched. If <span class="inlinecode">sorted</span> is <span class="inlinecode"><span class="d_keyword">true</span></span>, the target is sorted. Otherwise, the target
respects the <a href="http://en.wikipedia.org/wiki/Binary_heap">heap property</a>.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 10, 16, 2, 3, 1, 5, 0 ];
<span class="d_keyword">int</span>[] b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[3];
<u>topNCopy</u>(a, b, <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(b == [ 0, 1, 2 ]);
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="SetUnion" href="#SetUnion">SetUnion</a>(alias less = "a &lt; b",Rs...) if (allSatisfy!(isInputRange,Rs));
<br>SetUnion!(less,Rs) <a class="symbol symbol-anchor" name="setUnion" href="#setUnion">setUnion</a>(alias less = "a &lt; b", Rs...)(Rs <i>rs</i>);
</h3></div>

<div class="declaration-content"><p>Lazily computes the union of two or more ranges <span class="inlinecode">rs</span>. The ranges
are assumed to be sorted by <span class="inlinecode">less</span>. Elements in the output are not
unique; the length of the output is the sum of the lengths of the
inputs. (The <span class="inlinecode">length</span> member is offered if all ranges also have
length.) The element types of all ranges must have a common type.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">int</span>[] c = [ 10 ];
<span class="d_keyword">assert</span>(setUnion(a, b).length == a.length + b.length);
<span class="d_keyword">assert</span>(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));
<span class="d_keyword">assert</span>(equal(setUnion(a, c, b),
    [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="SetIntersection" href="#SetIntersection">SetIntersection</a>(alias less = "a &lt; b",Rs...) if (allSatisfy!(isInputRange,Rs));
<br>SetIntersection!(less,Rs) <a class="symbol symbol-anchor" name="setIntersection" href="#setIntersection">setIntersection</a>(alias less = "a &lt; b", Rs...)(Rs <i>ranges</i>);
</h3></div>

<div class="declaration-content"><p>Lazily computes the intersection of two or more input ranges <span class="inlinecode">rs</span>. The ranges are assumed to be sorted by <span class="inlinecode">less</span>. The element
types of all ranges must have a common type.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">int</span>[] c = [ 0, 1, 4, 5, 7, 8 ];
<span class="d_keyword">assert</span>(equal(setIntersection(a, a), a));
<span class="d_keyword">assert</span>(equal(setIntersection(a, b), [1, 2, 4, 7][]));
<span class="d_keyword">assert</span>(equal(setIntersection(a, b, c), [1, 4, 7][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="SetDifference" href="#SetDifference">SetDifference</a>(alias less = "a &lt; b",R1,R2) if (isInputRange!(R1) &amp;&amp; isInputRange!(R2));
<br>SetDifference!(less,R1,R2) <a class="symbol symbol-anchor" name="setDifference" href="#setDifference">setDifference</a>(alias less = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Lazily computes the difference of <span class="inlinecode">r1</span> and <span class="inlinecode">r2</span>. The two ranges
are assumed to be sorted by <span class="inlinecode">less</span>. The element types of the two
ranges must have a common type.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">assert</span>(equal(setDifference(a, b), [5, 9][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="SetSymmetricDifference" href="#SetSymmetricDifference">SetSymmetricDifference</a>(alias less = "a &lt; b",R1,R2) if (isInputRange!(R1) &amp;&amp; isInputRange!(R2));
<br>SetSymmetricDifference!(less,R1,R2) <a class="symbol symbol-anchor" name="setSymmetricDifference" href="#setSymmetricDifference">setSymmetricDifference</a>(alias less = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</h3></div>

<div class="declaration-content"><p>Lazily computes the symmetric difference of <span class="inlinecode">r1</span> and <span class="inlinecode">r2</span>,
i.e. the elements that are present in exactly one of <span class="inlinecode">r1</span> and <span class="inlinecode">r2</span>. The two ranges are assumed to be sorted by <span class="inlinecode">less</span>, and the
output is also sorted by <span class="inlinecode">less</span>. The element types of the two
ranges must have a common type.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">assert</span>(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>struct <a class="symbol symbol-anchor" name="NWayUnion" href="#NWayUnion">NWayUnion</a>(alias less,RangeOfRanges);
<br>NWayUnion!(less,RangeOfRanges) <a class="symbol symbol-anchor" name="nWayUnion" href="#nWayUnion">nWayUnion</a>(alias less = "a &lt; b", RangeOfRanges)(RangeOfRanges <i>ror</i>);
</h3></div>

<div class="declaration-content"><p>Computes the union of multiple sets. The input sets are passed as a
range of ranges and each is assumed to be sorted by <span class="inlinecode">less</span>. Computation is done lazily, one union element at a time. The
complexity of one <span class="inlinecode">popFront</span> operation is <b><i>&Omicron;</i>(</b><span class="inlinecode">log(ror.length)</span><b><i>)</i></b>. However, the length of <span class="inlinecode">ror</span> decreases as ranges
in it are exhausted, so the complexity of a full pass through <span class="inlinecode"><a class="symbol symbol-anchor" name="NWayUnion" href="#NWayUnion">NWayUnion</a></span> is dependent on the distribution of the lengths of ranges
contained within <span class="inlinecode">ror</span>. If all ranges have the same length <span class="inlinecode">n</span>
(worst case scenario), the complexity of a full pass through <span class="inlinecode"><a class="symbol symbol-anchor" name="NWayUnion" href="#NWayUnion">NWayUnion</a></span> is <b><i>&Omicron;</i>(</b><span class="inlinecode">n * ror.length * log(ror.length)</span><b><i>)</i></b>, i.e., <span class="inlinecode">log(ror.length)</span> times worse than just spanning all ranges in
turn. The output comes sorted (unstably) by <span class="inlinecode">less</span>.
</p>

<b>Warning:</b><br>
Because <span class="inlinecode"><a class="symbol symbol-anchor" name="NWayUnion" href="#NWayUnion">NWayUnion</a></span> does not allocate extra memory, it
will leave <span class="inlinecode">ror</span> modified. Namely, <span class="inlinecode"><a class="symbol symbol-anchor" name="NWayUnion" href="#NWayUnion">NWayUnion</a></span> assumes ownership
of <span class="inlinecode">ror</span> and discretionarily swaps and advances elements of it. If
you want <span class="inlinecode">ror</span> to preserve its contents after the call, you may
want to pass a duplicate to <span class="inlinecode"><a class="symbol symbol-anchor" name="NWayUnion" href="#NWayUnion">NWayUnion</a></span> (and perhaps cache the
duplicate in between calls).

<br><br>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> witness = [
    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8
];
<span class="d_keyword">assert</span>(equal(nWayUnion(a), witness[]));
</pre>
<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="largestPartialIntersection" href="#largestPartialIntersection">largestPartialIntersection</a>(alias less = "a &lt; b", RangeOfRanges, Range)(RangeOfRanges <i>ror</i>, Range <i>tgt</i>, SortOutput <i>sorted</i> = SortOutput.no);
</h3></div>

<div class="declaration-content"><p>Given a range of sorted forward ranges <span class="inlinecode">ror</span>, copies to <span class="inlinecode">tgt</span>
the elements that are common to most ranges, along with their number
of occurrences. All ranges in <span class="inlinecode">ror</span> are assumed to be sorted by <span class="inlinecode">less</span>. Only the most frequent <span class="inlinecode">tgt.length</span> elements are returned.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Figure which number can be found in most arrays of the set of
</span>
<span class="d_comment">// arrays below.
</span>
<span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">uint</span>)[1];
<u>largestPartialIntersection</u>(a, b);
<span class="d_comment">// First member is the item, second is the occurrence count
</span>
<span class="d_keyword">assert</span>(b[0] == tuple(7.0, 4u));
</pre>

<span class="inlinecode">7.0</span> is the correct answer because it occurs in <span class="inlinecode">4</span> out of the
<span class="inlinecode">5</span> inputs, more than any other number. The second member of the
resulting tuple is indeed <span class="inlinecode">4</span> (recording the number of occurrences
of <span class="inlinecode">7.0</span>). If more of the top-frequent numbers are needed, just
create a larger <span class="inlinecode">tgt</span> range. In the axample above, creating <span class="inlinecode">b</span>
with length <span class="inlinecode">2</span> yields <span class="inlinecode">tuple(1.0, 3u)</span> in the second position.
<br><br>

The function <span class="inlinecode"><a class="symbol symbol-anchor" name="largestPartialIntersection" href="#largestPartialIntersection">largestPartialIntersection</a></span> is useful for
e.g. searching an <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=inverted index">inverted index</a> for the documents most
likely to contain some terms of interest. The complexity of the search
is <b><i>&Omicron;</i>(</b><span class="inlinecode">n * log(tgt.length)</span><b><i>)</i></b>, where <span class="inlinecode">n</span> is the sum of lengths of
all input ranges. This approach is faster than keeping an associative
array of the occurrences and then selecting its top items, and also
requires less memory (<span class="inlinecode"><a class="symbol symbol-anchor" name="largestPartialIntersection" href="#largestPartialIntersection">largestPartialIntersection</a></span> builds its
result directly in <span class="inlinecode">tgt</span> and requires no extra memory).

<br><br>
<b>Warning:</b><br>
Because <span class="inlinecode"><a class="symbol symbol-anchor" name="largestPartialIntersection" href="#largestPartialIntersection">largestPartialIntersection</a></span> does not allocate
extra memory, it will leave <span class="inlinecode">ror</span> modified. Namely, <span class="inlinecode"><a class="symbol symbol-anchor" name="largestPartialIntersection" href="#largestPartialIntersection">largestPartialIntersection</a></span> assumes ownership of <span class="inlinecode">ror</span> and
discretionarily swaps and advances elements of it. If you want <span class="inlinecode">ror</span> to preserve its contents after the call, you may want to pass a
duplicate to <span class="inlinecode"><a class="symbol symbol-anchor" name="largestPartialIntersection" href="#largestPartialIntersection">largestPartialIntersection</a></span> (and perhaps cache the
duplicate in between calls).<br><br>

</div>

<hr><div class="row-fluid declaration"><h3>void <a class="symbol symbol-anchor" name="largestPartialIntersectionWeighted" href="#largestPartialIntersectionWeighted">largestPartialIntersectionWeighted</a>(alias less = "a &lt; b", RangeOfRanges, Range, WeightsAA)(RangeOfRanges <i>ror</i>, Range <i>tgt</i>, WeightsAA <i>weights</i>, SortOutput <i>sorted</i> = SortOutput.no);
</h3></div>

<div class="declaration-content"><p>Similar to <span class="inlinecode">largestPartialIntersection</span>, but associates a weight
with each distinct element in the intersection.
</p>

<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Figure which number can be found in most arrays of the set of
</span>
<span class="d_comment">// arrays below, with specific per-element weights
</span>
<span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">uint</span>)[1];
<span class="d_keyword">double</span>[<span class="d_keyword">double</span>] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];
<u>largestPartialIntersectionWeighted</u>(a, b, weights);
<span class="d_comment">// First member is the item, second is the occurrence count
</span>
<span class="d_keyword">assert</span>(b[0] == tuple(4.0, 2u));
</pre>

The correct answer in this case is <span class="inlinecode">4.0</span>, which, although only
appears two times, has a total weight <span class="inlinecode">4.6</span> (three times its weight
<span class="inlinecode">2.3</span>). The value <span class="inlinecode">7</span> is weighted with <span class="inlinecode">1.1</span> and occurs four
times for a total weight <span class="inlinecode">4.4</span>.<br><br>

</div>



				</div>
			</div>
			
			<hr>
			
			<div class="pull-right">
				<footer>
					<p>&copy; Andrei Alexandrescu 2008-.

 2012-2012</p>
				</footer>
			</div>
		</div>
	</div><!--/.fluid-container-->

	<!-- Bootstrap javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="bootDoc/assets/js/jquery.js"></script>
	<script src="bootDoc/assets/js/bootstrap-transition.js"></script>
	<script src="bootDoc/assets/js/bootstrap-alert.js"></script>
	<script src="bootDoc/assets/js/bootstrap-modal.js"></script>
	<script src="bootDoc/assets/js/bootstrap-dropdown.js"></script>
	<script src="bootDoc/assets/js/bootstrap-scrollspy.js"></script>
	<script src="bootDoc/assets/js/bootstrap-tab.js"></script>
	<script src="bootDoc/assets/js/bootstrap-tooltip.js"></script>
	<script src="bootDoc/assets/js/bootstrap-popover.js"></script>
	<script src="bootDoc/assets/js/bootstrap-button.js"></script>
	<script src="bootDoc/assets/js/bootstrap-collapse.js"></script>
	<script src="bootDoc/assets/js/bootstrap-carousel.js"></script>
	<script src="bootDoc/assets/js/bootstrap-typeahead.js"></script>
	
	<!-- bootDoc javascript
	================================================== -->
	<script src="bootDoc/bootdoc.js"></script>
	
	</body>
</html>

