<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8">
	<title>std.regex - Phobos documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- styles -->
	<link href="bootDoc/assets/css/bootstrap.css" rel="stylesheet">
	<style type="text/css">
		body {
		padding-top: 60px;
		padding-bottom: 40px;
		}
		.sidebar-nav {
		padding: 9px 0;
		}
	</style>
	<link href="bootDoc/assets/css/bootstrap-responsive.css" rel="stylesheet">
	<link href="bootDoc/bootdoc.css" rel="stylesheet">

	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- fav and touch icons -->
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="bootDoc/assets/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="bootDoc/assets/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="bootDoc/assets/ico/apple-touch-icon-57-precomposed.png">
	
	<!-- Introduce DDoc settings required by JavaScript -->
	<script type="text/javascript">
		var Title = 'std.regex';
		var SourceRepository = 'https://github.com/D-Programming-Language/phobos/tree/master';
		var PackageSeparator = '.';
	</script>
	
	<style type="text/css">
		.ddoc-icon-variable { background-image: url('bootDoc/ddoc-icons/var.png'); }
		.ddoc-icon-function { background-image: url('bootDoc/ddoc-icons/func.png'); }
		.ddoc-icon-property { background-image: url('bootDoc/ddoc-icons/property.png'); }
		.ddoc-icon-struct { background-image: url('bootDoc/ddoc-icons/struct.png'); }
		.ddoc-icon-class { background-image: url('bootDoc/ddoc-icons/class.png'); }
		.ddoc-icon-enum { background-image: url('bootDoc/ddoc-icons/enum.png'); }
		.ddoc-icon-template { background-image: url('bootDoc/ddoc-icons/template.png'); }
	</style>
	</head>

	<body>
	<!--
	JavaScript reaps the module list from this element.
	This is required for the MODULES macro to be reusable
	in a noscript element later.
	-->
	<ul id="module-list-source" class="hidden">
		
	<li class="sidebar-list-entry tree-leaf"><a href="index.html" title="index"><i class="icon-th"></i>index</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.curl.html" title="etc.c.curl"><i class="icon-th"></i>etc.c.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.sqlite3.html" title="etc.c.sqlite3"><i class="icon-th"></i>etc.c.sqlite3</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.zlib.html" title="etc.c.zlib"><i class="icon-th"></i>etc.c.zlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.algorithm.html" title="std.algorithm"><i class="icon-th"></i>std.algorithm</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.array.html" title="std.array"><i class="icon-th"></i>std.array</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.ascii.html" title="std.ascii"><i class="icon-th"></i>std.ascii</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.base64.html" title="std.base64"><i class="icon-th"></i>std.base64</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bigint.html" title="std.bigint"><i class="icon-th"></i>std.bigint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bitmanip.html" title="std.bitmanip"><i class="icon-th"></i>std.bitmanip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.fenv.html" title="std.c.fenv"><i class="icon-th"></i>std.c.fenv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.locale.html" title="std.c.locale"><i class="icon-th"></i>std.c.locale</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.math.html" title="std.c.math"><i class="icon-th"></i>std.c.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.process.html" title="std.c.process"><i class="icon-th"></i>std.c.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdarg.html" title="std.c.stdarg"><i class="icon-th"></i>std.c.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stddef.html" title="std.c.stddef"><i class="icon-th"></i>std.c.stddef</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdio.html" title="std.c.stdio"><i class="icon-th"></i>std.c.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdlib.html" title="std.c.stdlib"><i class="icon-th"></i>std.c.stdlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.string.html" title="std.c.string"><i class="icon-th"></i>std.c.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.time.html" title="std.c.time"><i class="icon-th"></i>std.c.time</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.wcharh.html" title="std.c.wcharh"><i class="icon-th"></i>std.c.wcharh</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.com.html" title="std.c.windows.com"><i class="icon-th"></i>std.c.windows.com</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.stat.html" title="std.c.windows.stat"><i class="icon-th"></i>std.c.windows.stat</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.windows.html" title="std.c.windows.windows"><i class="icon-th"></i>std.c.windows.windows</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.winsock.html" title="std.c.windows.winsock"><i class="icon-th"></i>std.c.windows.winsock</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.compiler.html" title="std.compiler"><i class="icon-th"></i>std.compiler</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.complex.html" title="std.complex"><i class="icon-th"></i>std.complex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.concurrency.html" title="std.concurrency"><i class="icon-th"></i>std.concurrency</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.container.html" title="std.container"><i class="icon-th"></i>std.container</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.conv.html" title="std.conv"><i class="icon-th"></i>std.conv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.cstream.html" title="std.cstream"><i class="icon-th"></i>std.cstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.csv.html" title="std.csv"><i class="icon-th"></i>std.csv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.datetime.html" title="std.datetime"><i class="icon-th"></i>std.datetime</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.demangle.html" title="std.demangle"><i class="icon-th"></i>std.demangle</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.encoding.html" title="std.encoding"><i class="icon-th"></i>std.encoding</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.exception.html" title="std.exception"><i class="icon-th"></i>std.exception</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.file.html" title="std.file"><i class="icon-th"></i>std.file</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.format.html" title="std.format"><i class="icon-th"></i>std.format</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.functional.html" title="std.functional"><i class="icon-th"></i>std.functional</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.getopt.html" title="std.getopt"><i class="icon-th"></i>std.getopt</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.json.html" title="std.json"><i class="icon-th"></i>std.json</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.math.html" title="std.math"><i class="icon-th"></i>std.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mathspecial.html" title="std.mathspecial"><i class="icon-th"></i>std.mathspecial</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.md5.html" title="std.md5"><i class="icon-th"></i>std.md5</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.metastrings.html" title="std.metastrings"><i class="icon-th"></i>std.metastrings</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mmfile.html" title="std.mmfile"><i class="icon-th"></i>std.mmfile</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.curl.html" title="std.net.curl"><i class="icon-th"></i>std.net.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.isemail.html" title="std.net.isemail"><i class="icon-th"></i>std.net.isemail</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.numeric.html" title="std.numeric"><i class="icon-th"></i>std.numeric</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.outbuffer.html" title="std.outbuffer"><i class="icon-th"></i>std.outbuffer</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.parallelism.html" title="std.parallelism"><i class="icon-th"></i>std.parallelism</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.path.html" title="std.path"><i class="icon-th"></i>std.path</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.process.html" title="std.process"><i class="icon-th"></i>std.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.random.html" title="std.random"><i class="icon-th"></i>std.random</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.range.html" title="std.range"><i class="icon-th"></i>std.range</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.regex.html" title="std.regex"><i class="icon-th"></i>std.regex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.signals.html" title="std.signals"><i class="icon-th"></i>std.signals</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socket.html" title="std.socket"><i class="icon-th"></i>std.socket</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socketstream.html" title="std.socketstream"><i class="icon-th"></i>std.socketstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdarg.html" title="std.stdarg"><i class="icon-th"></i>std.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdint.html" title="std.stdint"><i class="icon-th"></i>std.stdint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdio.html" title="std.stdio"><i class="icon-th"></i>std.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdiobase.html" title="std.stdiobase"><i class="icon-th"></i>std.stdiobase</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stream.html" title="std.stream"><i class="icon-th"></i>std.stream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.string.html" title="std.string"><i class="icon-th"></i>std.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.syserror.html" title="std.syserror"><i class="icon-th"></i>std.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.system.html" title="std.system"><i class="icon-th"></i>std.system</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.traits.html" title="std.traits"><i class="icon-th"></i>std.traits</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typecons.html" title="std.typecons"><i class="icon-th"></i>std.typecons</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typetuple.html" title="std.typetuple"><i class="icon-th"></i>std.typetuple</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uni.html" title="std.uni"><i class="icon-th"></i>std.uni</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uri.html" title="std.uri"><i class="icon-th"></i>std.uri</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.utf.html" title="std.utf"><i class="icon-th"></i>std.utf</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.variant.html" title="std.variant"><i class="icon-th"></i>std.variant</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.charset.html" title="std.windows.charset"><i class="icon-th"></i>std.windows.charset</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.iunknown.html" title="std.windows.iunknown"><i class="icon-th"></i>std.windows.iunknown</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.registry.html" title="std.windows.registry"><i class="icon-th"></i>std.windows.registry</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.syserror.html" title="std.windows.syserror"><i class="icon-th"></i>std.windows.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.xml.html" title="std.xml"><i class="icon-th"></i>std.xml</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zip.html" title="std.zip"><i class="icon-th"></i>std.zip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zlib.html" title="std.zlib"><i class="icon-th"></i>std.zlib</a></li>
	</ul>
	
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container-fluid">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="index.html">Phobos</a>
				<div class="nav-collapse">
					<ul class="nav">
						<li class="active"><a href="index.html">Reference</a></li>
					</ul>
					
					<form id="gotosymbol" class="navbar-search pull-left hidden">
						<input type="text" class="search-query" placeholder="Go to symbol in std.regex" data-provide="typeahead" data-items="4">
					</form>
					
					<p class="navbar-text pull-right"><a href="https://github.com/D-Programming-Language/phobos">Github Page</a></p>
				</div><!--/.nav-collapse -->
			</div>
		</div>
	</div>

	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span2">
				<div class="well sidebar-nav">
				<ul class="nav nav-list">
					<li id="module-list" class="nav-header sidebar-list-entry">Modules<li>
					<noscript>
						
	<li class="sidebar-list-entry tree-leaf"><a href="index.html" title="index"><i class="icon-th"></i>index</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.curl.html" title="etc.c.curl"><i class="icon-th"></i>etc.c.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.sqlite3.html" title="etc.c.sqlite3"><i class="icon-th"></i>etc.c.sqlite3</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="etc.c.zlib.html" title="etc.c.zlib"><i class="icon-th"></i>etc.c.zlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.algorithm.html" title="std.algorithm"><i class="icon-th"></i>std.algorithm</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.array.html" title="std.array"><i class="icon-th"></i>std.array</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.ascii.html" title="std.ascii"><i class="icon-th"></i>std.ascii</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.base64.html" title="std.base64"><i class="icon-th"></i>std.base64</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bigint.html" title="std.bigint"><i class="icon-th"></i>std.bigint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.bitmanip.html" title="std.bitmanip"><i class="icon-th"></i>std.bitmanip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.fenv.html" title="std.c.fenv"><i class="icon-th"></i>std.c.fenv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.locale.html" title="std.c.locale"><i class="icon-th"></i>std.c.locale</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.math.html" title="std.c.math"><i class="icon-th"></i>std.c.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.process.html" title="std.c.process"><i class="icon-th"></i>std.c.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdarg.html" title="std.c.stdarg"><i class="icon-th"></i>std.c.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stddef.html" title="std.c.stddef"><i class="icon-th"></i>std.c.stddef</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdio.html" title="std.c.stdio"><i class="icon-th"></i>std.c.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.stdlib.html" title="std.c.stdlib"><i class="icon-th"></i>std.c.stdlib</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.string.html" title="std.c.string"><i class="icon-th"></i>std.c.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.time.html" title="std.c.time"><i class="icon-th"></i>std.c.time</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.wcharh.html" title="std.c.wcharh"><i class="icon-th"></i>std.c.wcharh</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.com.html" title="std.c.windows.com"><i class="icon-th"></i>std.c.windows.com</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.stat.html" title="std.c.windows.stat"><i class="icon-th"></i>std.c.windows.stat</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.windows.html" title="std.c.windows.windows"><i class="icon-th"></i>std.c.windows.windows</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.c.windows.winsock.html" title="std.c.windows.winsock"><i class="icon-th"></i>std.c.windows.winsock</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.compiler.html" title="std.compiler"><i class="icon-th"></i>std.compiler</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.complex.html" title="std.complex"><i class="icon-th"></i>std.complex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.concurrency.html" title="std.concurrency"><i class="icon-th"></i>std.concurrency</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.container.html" title="std.container"><i class="icon-th"></i>std.container</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.conv.html" title="std.conv"><i class="icon-th"></i>std.conv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.cstream.html" title="std.cstream"><i class="icon-th"></i>std.cstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.csv.html" title="std.csv"><i class="icon-th"></i>std.csv</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.datetime.html" title="std.datetime"><i class="icon-th"></i>std.datetime</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.demangle.html" title="std.demangle"><i class="icon-th"></i>std.demangle</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.encoding.html" title="std.encoding"><i class="icon-th"></i>std.encoding</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.exception.html" title="std.exception"><i class="icon-th"></i>std.exception</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.file.html" title="std.file"><i class="icon-th"></i>std.file</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.format.html" title="std.format"><i class="icon-th"></i>std.format</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.functional.html" title="std.functional"><i class="icon-th"></i>std.functional</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.getopt.html" title="std.getopt"><i class="icon-th"></i>std.getopt</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.json.html" title="std.json"><i class="icon-th"></i>std.json</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.math.html" title="std.math"><i class="icon-th"></i>std.math</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mathspecial.html" title="std.mathspecial"><i class="icon-th"></i>std.mathspecial</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.md5.html" title="std.md5"><i class="icon-th"></i>std.md5</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.metastrings.html" title="std.metastrings"><i class="icon-th"></i>std.metastrings</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.mmfile.html" title="std.mmfile"><i class="icon-th"></i>std.mmfile</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.curl.html" title="std.net.curl"><i class="icon-th"></i>std.net.curl</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.net.isemail.html" title="std.net.isemail"><i class="icon-th"></i>std.net.isemail</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.numeric.html" title="std.numeric"><i class="icon-th"></i>std.numeric</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.outbuffer.html" title="std.outbuffer"><i class="icon-th"></i>std.outbuffer</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.parallelism.html" title="std.parallelism"><i class="icon-th"></i>std.parallelism</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.path.html" title="std.path"><i class="icon-th"></i>std.path</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.process.html" title="std.process"><i class="icon-th"></i>std.process</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.random.html" title="std.random"><i class="icon-th"></i>std.random</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.range.html" title="std.range"><i class="icon-th"></i>std.range</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.regex.html" title="std.regex"><i class="icon-th"></i>std.regex</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.signals.html" title="std.signals"><i class="icon-th"></i>std.signals</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socket.html" title="std.socket"><i class="icon-th"></i>std.socket</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.socketstream.html" title="std.socketstream"><i class="icon-th"></i>std.socketstream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdarg.html" title="std.stdarg"><i class="icon-th"></i>std.stdarg</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdint.html" title="std.stdint"><i class="icon-th"></i>std.stdint</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdio.html" title="std.stdio"><i class="icon-th"></i>std.stdio</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stdiobase.html" title="std.stdiobase"><i class="icon-th"></i>std.stdiobase</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.stream.html" title="std.stream"><i class="icon-th"></i>std.stream</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.string.html" title="std.string"><i class="icon-th"></i>std.string</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.syserror.html" title="std.syserror"><i class="icon-th"></i>std.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.system.html" title="std.system"><i class="icon-th"></i>std.system</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.traits.html" title="std.traits"><i class="icon-th"></i>std.traits</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typecons.html" title="std.typecons"><i class="icon-th"></i>std.typecons</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.typetuple.html" title="std.typetuple"><i class="icon-th"></i>std.typetuple</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uni.html" title="std.uni"><i class="icon-th"></i>std.uni</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.uri.html" title="std.uri"><i class="icon-th"></i>std.uri</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.utf.html" title="std.utf"><i class="icon-th"></i>std.utf</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.variant.html" title="std.variant"><i class="icon-th"></i>std.variant</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.charset.html" title="std.windows.charset"><i class="icon-th"></i>std.windows.charset</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.iunknown.html" title="std.windows.iunknown"><i class="icon-th"></i>std.windows.iunknown</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.registry.html" title="std.windows.registry"><i class="icon-th"></i>std.windows.registry</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.windows.syserror.html" title="std.windows.syserror"><i class="icon-th"></i>std.windows.syserror</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.xml.html" title="std.xml"><i class="icon-th"></i>std.xml</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zip.html" title="std.zip"><i class="icon-th"></i>std.zip</a></li>
	<li class="sidebar-list-entry tree-leaf"><a href="std.zlib.html" title="std.zlib"><i class="icon-th"></i>std.zlib</a></li>
					</noscript>
					<li id="symbol-list" class="nav-header sidebar-list-entry hidden">std.regex</li>
				</ul>
				</div><!--/.well -->
			</div><!--/span-->
			
			<div class="span10">
				<div class="row-fluid">
					<div class="span11">
						<ul id="module-breadcrumb" class="breadcrumb">
							<noscript><h1>std.regex</h1></noscript>
						</ul>
						
					</div>
					<div class="span1 offset11">
						<a href="index.html"><img src="dlogo-small.png" alt="The D Programming Language"/></a>
					</div>
				</div>
				<div id="declaration-list">
					<!-- Generated by Ddoc from phobos\std\regex.d -->
<dl><p><h3><a id="Intro">Intro</a></h3>
  <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Regular expressions">Regular expressions</a>
 are a commonly used method of pattern matching
  on strings, with <i><span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a></i> being a catchy word for a pattern in this domain
  specific language. Typical problems usually solved by regular expressions
  include validation of user input and the ubiquitous find &amp; replace
  in text processing utilities.
</p>

<p> <h3><a id="Synopsis">Synopsis</a></h3>
<pre class="d_code"><span class="d_keyword">import</span> std.<u>regex</u>;
<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">void</span> main()
{
    <span class="d_comment">// Print out all possible dd/mm/yy(yy) dates found in user input.
</span>
    <span class="d_comment">// g - global: find all matches.
</span>
    <span class="d_keyword">auto</span> r = <u>regex</u>(<span class="d_string">r"\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\b"</span>, <span class="d_string">"g"</span>);
    <span class="d_keyword">foreach</span>(line; stdin.byLine)
    {
      <span class="d_comment">// Match returns a range that can be iterated
</span>
      <span class="d_comment">// to get all subsequent matches.
</span>
      <span class="d_keyword">foreach</span>(c; match(line, r))
          writeln(c.hit);
    }
}
...

<span class="d_comment">// Create a static regex at compile-time, which contains fast native code.
</span>
<span class="d_keyword">enum</span> ctr = ctRegex!(<span class="d_string">`^.*/([^/]+)/?$`</span>);

<span class="d_comment">// It works just like a normal regex:
</span>
<span class="d_keyword">auto</span> m2 = match(<span class="d_string">"foo/bar"</span>, ctr);   <span class="d_comment">// First match found here, if any
</span>
<span class="d_keyword">assert</span>(m2);   <span class="d_comment">// Be sure to check if there is a match before examining contents!
</span>
<span class="d_keyword">assert</span>(m2.captures[1] == <span class="d_string">"bar"</span>);   <span class="d_comment">// Captures is a range of submatches: 0 = full match.
</span>

...

<span class="d_comment">// The result of the match is directly testable with if/assert/while.
</span>
<span class="d_comment">// e.g. test if a string consists of letters:
</span>
<span class="d_keyword">assert</span>(match(<span class="d_string">"Letter"</span>, <span class="d_string">`^\p{L}+$`</span>));


</pre>
  <h3><a id="Syntax and general information">Syntax and general information</a></h3>
  The general usage guideline is to keep <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> complexity on the side of simplicity,
  as its capabilities reside in purely character-level manipulation.
  As such it's ill-suited for tasks involving higher level invariants
  like matching an integer number <u>bounded</u> in an [a,b] interval.
  Checks of this sort of are better addressed by additional post-processing.
<br><br>

  The basic syntax shouldn't surprise experienced users of regular expressions.
  For an introduction to <span class="inlinecode">std.<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a></span> see a
  <a href="http://dlang.org/regular-expression.html">short tour</a> of the module API
  and its abilities.
<br><br>

  There are other web resources on regular expressions to help newcomers,
  and a good <a href="http://www.regular-expressions.info">reference with tutorial</a>
  can easily be found.
<br><br>

  This library uses a remarkably common ECMAScript syntax flavor
  with the following extensions:
  <ul>   <li>Named subexpressions, with Python syntax. </li>
    <li>Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.</li>
    <li>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</li>
  </ul>
<br><br>

  <h3><div align="center"> Pattern syntax  </div></h3>
  <i>std.<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> operates on codepoint level,
    'character' in this table denotes a single Unicode codepoint.</i>
  <table border="1" cellspacing="0" cellpadding="5" >    <tr><td valign=top><b>Pattern element</b></td> <td valign=top><b>Semantics </b></td> </tr>
    <tr><td valign=top><b>Atoms</b></td> <td valign=top><b>Match single characters </b></td> </tr>
    <tr><td valign=top><i>any character except [{|*+?()^$ </i></td> <td valign=top>Matches the character itself. </td> </tr>
    <tr><td valign=top><i>. </i></td> <td valign=top>In single line mode matches any character.
      Otherwise it matches any character except '\n' and '\r'. </td> </tr>
    <tr><td valign=top><i>[class] </i></td> <td valign=top>Matches a single character
      that belongs to this character class. </td> </tr>
    <tr><td valign=top><i>[^class] </i></td> <td valign=top>Matches a single character that
      does <u>not</u> belong to this character class.</td> </tr>
    <tr><td valign=top><i>\cC </i></td> <td valign=top>Matches the control character corresponding to letter C</td> </tr>
    <tr><td valign=top><i>\xXX </i></td> <td valign=top>Matches a character with hexadecimal value of XX. </td> </tr>
    <tr><td valign=top><i>\uXXXX </i></td> <td valign=top>Matches a character  with hexadecimal value of XXXX. </td> </tr>
    <tr><td valign=top><i>\U00YYYYYY </i></td> <td valign=top>Matches a character with hexadecimal value of YYYYYY. </td> </tr>
    <tr><td valign=top><i>\f </i></td> <td valign=top>Matches a formfeed character. </td> </tr>
    <tr><td valign=top><i>\n </i></td> <td valign=top>Matches a linefeed character. </td> </tr>
    <tr><td valign=top><i>\r </i></td> <td valign=top>Matches a carriage return character. </td> </tr>
    <tr><td valign=top><i>\t </i></td> <td valign=top>Matches a tab character. </td> </tr>
    <tr><td valign=top><i>\v </i></td> <td valign=top>Matches a vertical tab character. </td> </tr>
    <tr><td valign=top><i>\d </i></td> <td valign=top>Matches any Unicode digit. </td> </tr>
    <tr><td valign=top><i>\D </i></td> <td valign=top>Matches any character except Unicode digits. </td> </tr>
    <tr><td valign=top><i>\w </i></td> <td valign=top>Matches any word character (note: this includes numbers).</td> </tr>
    <tr><td valign=top><i>\W </i></td> <td valign=top>Matches any non-word character.</td> </tr>
    <tr><td valign=top><i>\s </i></td> <td valign=top>Matches whitespace, same as \p{White_Space}.</td> </tr>
    <tr><td valign=top><i>\S </i></td> <td valign=top>Matches any character except those recognized as <i>\s </i>. </td> </tr>
    <tr><td valign=top><i>\\ </i></td> <td valign=top>Matches \ character. </td> </tr>
    <tr><td valign=top><i>\c where c is one of [|*+?() </i></td> <td valign=top>Matches the character c itself. </td> </tr>
    <tr><td valign=top><i>\p{PropertyName} </i></td> <td valign=top>Matches a character that belongs
        to the Unicode PropertyName set.
      Single letter abbreviations can be used without surrounding {,}. </td> </tr>
    <tr><td valign=top><i>\P{PropertyName} </i></td> <td valign=top>Matches a character that does not belong
        to the Unicode PropertyName set.
      Single letter abbreviations can be used without surrounding {,}. </td> </tr>
    <tr><td valign=top><i>\p{InBasicLatin} </i></td> <td valign=top>Matches any character that is part of
          the BasicLatin Unicode <u>block</u>.</td> </tr>
    <tr><td valign=top><i>\P{InBasicLatin} </i></td> <td valign=top>Matches any character except ones in
          the BasicLatin Unicode <u>block</u>.</td> </tr>
    <tr><td valign=top><i>\p{Cyrilic} </i></td> <td valign=top>Matches any character that is part of
        Cyrilic <u>script</u>.</td> </tr>
    <tr><td valign=top><i>\P{Cyrilic} </i></td> <td valign=top>Matches any character except ones in
        Cyrilic <u>script</u>.</td> </tr>
    <tr><td valign=top><b>Quantifiers</b></td> <td valign=top><b>Specify repetition of other elements</b></td> </tr>
    <tr><td valign=top><i>* </i></td> <td valign=top>Matches previous character/subexpression 0 or more times.
      Greedy version - tries as many times as possible.</td> </tr>
    <tr><td valign=top><i>*? </i></td> <td valign=top>Matches previous character/subexpression 0 or more times.
      Lazy version  - stops as early as possible.</td> </tr>
    <tr><td valign=top><i>+ </i></td> <td valign=top>Matches previous character/subexpression 1 or more times.
      Greedy version - tries as many times as possible.</td> </tr>
    <tr><td valign=top><i>+? </i></td> <td valign=top>Matches previous character/subexpression 1 or more times.
      Lazy version  - stops as early as possible.</td> </tr>
    <tr><td valign=top><i>{n} </i></td> <td valign=top>Matches previous character/subexpression exactly n times. </td> </tr>
    <tr><td valign=top><i>{n&#44} </i></td> <td valign=top>Matches previous character/subexpression n times or more.
      Greedy version - tries as many times as possible. </td> </tr>
    <tr><td valign=top><i>{n&#44}? </i></td> <td valign=top>Matches previous character/subexpression n times or more.
      Lazy version - stops as early as possible.</td> </tr>
    <tr><td valign=top><i>{n&#44m} </i></td> <td valign=top>Matches previous character/subexpression n to m times.
      Greedy version - tries as many times as possible, but no more than m times. </td> </tr>
    <tr><td valign=top><i>{n&#44m}? </i></td> <td valign=top>Matches previous character/subexpression n to m times.
      Lazy version - stops as early as possible, but no less then n times.</td> </tr>
    <tr><td valign=top><b>Other</b></td> <td valign=top><b>Subexpressions &amp; alternations </b></td> </tr>
    <tr><td valign=top><i>(<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Matches subexpression <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>,
      saving matched portion of text for later retrieval. </td> </tr>
    <tr><td valign=top><i>(?:<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Matches subexpression <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>,
      <u>not</u> saving matched portion of text. Useful to speed up matching. </td> </tr>
    <tr><td valign=top><i>A|B </i></td> <td valign=top>Matches subexpression A, or failing that, matches B. </td> </tr>
    <tr><td valign=top><i>(?P&lt;name&gt;<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Matches named subexpression
        <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> labeling it with name 'name'.
        When referring to a matched portion of text,
        names work like aliases in addition to direct numbers.
     </td> </tr>
    <tr><td valign=top><b>Assertions</b></td> <td valign=top><b>Match position rather than character </b></td> </tr>
    <tr><td valign=top><i>^ </i></td> <td valign=top>Matches at the begining of input or line (in multiline mode).</td> </tr>
    <tr><td valign=top><i>$ </i></td> <td valign=top>Matches at the end of input or line (in multiline mode). </td> </tr>
    <tr><td valign=top><i>\b </i></td> <td valign=top>Matches at word boundary. </td> </tr>
    <tr><td valign=top><i>\B </i></td> <td valign=top>Matches when <u>not</u> at word boundary. </td> </tr>
    <tr><td valign=top><i>(?=<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Zero-width lookahead assertion.
        Matches at a point where the subexpression
        <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> could be matched starting from the current position.
      </td> </tr>
    <tr><td valign=top><i>(?!<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Zero-width negative lookahead assertion.
        Matches at a point where the subexpression
        <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> could <u>not</u> be matched starting from the current position.
      </td> </tr>
    <tr><td valign=top><i>(?&lt;=<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Zero-width lookbehind assertion. Matches at a point
        where the subexpression <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> could be matched ending
        at the current position (matching goes backwards).
      </td> </tr>
    <tr><td valign=top><i>(?&lt;!<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>) </i></td> <td valign=top>Zero-width negative lookbehind assertion.
      Matches at a point where the subexpression <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a> could <u>not</u>
      be matched ending at the current position (matching goes backwards).
     </td> </tr>
   </table>
<br><br>

  <h3><div align="center"> Character classes  </div></h3>
  <table border="1" cellspacing="0" cellpadding="5" >    <tr><td valign=top><b>Pattern element</b></td> <td valign=top><b>Semantics </b></td> </tr>
    <tr><td valign=top><i>Any atom </i></td> <td valign=top>Has the same meaning as outside of a character class.</td> </tr>
    <tr><td valign=top><i>a-z </i></td> <td valign=top>Includes characters a, b, c, ..., z. </td> </tr>
    <tr><td valign=top><i>[a||b]&#44 [a--b]&#44 [a~~b]&#44 [a&amp;&b] </i></td> <td valign=top>Where a, b are arbitrary classes,
     means union, set difference, symmetric set difference, and intersection respectively.
     <i>Any sequence of character class elements implicitly forms a union.</i> </td> </tr>
   </table>
<br><br>

  <h3><div align="center"> Regex flags  </div></h3>
  <table border="1" cellspacing="0" cellpadding="5" >    <tr><td valign=top><b>Flag</b></td> <td valign=top><b>Semantics </b></td> </tr>
    <tr><td valign=top><i>g </i></td> <td valign=top>Global <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>, repeat over the whole input. </td> </tr>
    <tr><td valign=top><i>i </i></td> <td valign=top>Case insensitive matching. </td> </tr>
    <tr><td valign=top><i>m </i></td> <td valign=top>Multi-line mode, match ^, $ on start and end line separators
       as well as start and end of input.</td> </tr>
    <tr><td valign=top><i>s </i></td> <td valign=top>Single-line mode, makes . match '\n' and '\r' as well. </td> </tr>
    <tr><td valign=top><i>x </i></td> <td valign=top>Free-form syntax, ignores whitespace in pattern,
      useful for formatting complex regular expressions. </td> </tr>
   </table>
<br><br>

  <h3><a id="Unicode support">Unicode support</a></h3>
<br><br>

  This library provides full Level 1 support* according to
    <a href="http://unicode.org/reports/tr18/">UTS 18</a>. Specifically:
  <ul>   <li>1.1 Hex notation via any of \uxxxx, \U00YYYYYY, \xZZ.</li>
    <li>1.2 Unicode properties.</li>
    <li>1.3 Character classes with set operations.</li>
    <li>1.4 Word boundaries use the full set of "word" characters.</li>
    <li>1.5 Using simple casefolding to match case
        insensitively across the full range of codepoints.</li>
    <li>1.6 Respecting line breaks as any of
        \u000A | \u000B | \u000C | \u000D | \u0085 | \u2028 | \u2029 | \u000D\u000A.</li>
    <li>1.7 Operating on codepoint level.</li>
  </ul>
  *With exception of point 1.1.1, as of yet, normalization of input
    is expected to be enforced by user.
<br><br>

    <h3><a id="Replace format string">Replace format string</a></h3>
<br><br>

    A set of functions in this module that do the substitution rely
    on a simple format to guide the process. In particular the table below
    applies to the <span class="inlinecode">format</span> argument of
    <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
 and <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>
.
<br><br>

    The format string can reference parts of match using the following notation.
    <table border="1" cellspacing="0" cellpadding="5" >        <tr><td valign=top><b>Format specifier</b></td> <td valign=top><b>Replaced by </b></td> </tr>
        <tr><td valign=top><i>$&amp; </i></td> <td valign=top>the whole match. </td> </tr>
        <tr><td valign=top><i>$` </i></td> <td valign=top>part of input <i>preceding</i> the match. </td> </tr>
        <tr><td valign=top><i>$' </i></td> <td valign=top>part of input <i>following</i> the match. </td> </tr>
        <tr><td valign=top><i>$$ </i></td> <td valign=top>'$' character. </td> </tr>
        <tr><td valign=top><i>\c &#44 where c is any character </i></td> <td valign=top>the character c itself. </td> </tr>
        <tr><td valign=top><i>\\ </i></td> <td valign=top>'\' character. </td> </tr>
        <tr><td valign=top><i>&#36;1 .. &#36;99 </i></td> <td valign=top>submatch number 1 to 99 respectively. </td> </tr>
     </table>
<br><br>

  <h3><a id="Slicing and zero memory allocations orientation">Slicing and zero memory allocations orientation</a></h3>
<br><br>

  All matches returned by pattern matching functionality in this library
    are slices of the original input. The notable exception is the <span class="inlinecode">replace</span>
    family of functions  that generate a new string from the input.
<br><br>

    In cases where producing the replacement is the ultimate goal
    <a class="symbol-link" href="#replaceFirstInto"><span class="inlinecode">replaceFirstInto</span></a>
 and <a class="symbol-link" href="#replaceAllInto"><span class="inlinecode">replaceAllInto</span></a>
 could come in handy
    as functions that  avoid allocations even for replacement.

</p>
<h3><a id="License">License, <a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

</a></h3>
<h3><a id="Authors">Authors, Dmitry Olshansky,
<br><br>

    API and utility constructs are modeled after the original <span class="inlinecode">std.<span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a></span>
  by Walter Bright and Andrei Alexandrescu.

</a></h3>
<dt>Source:</dt><dd>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/regex.d">std/regex.d</a>

</dd>
</dl>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Regex">&nbsp;</span><a class="symbol-link" href="#Regex">Regex</a>(Char);
</h3></div>
<div class="declaration-content"><dl><p><span class="inlinecode"><span class="symbol-target" id="Regex">&nbsp;</span><a class="symbol-link" href="#Regex">Regex</a></span> object holds regular expression pattern in compiled form.
    Instances of this object are constructed via calls to <span class="inlinecode">regex</span>.
    This is an intended form for caching and storage of frequently
    used regular expressions.</p>

</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>const nothrow bool <span class="symbol-target" id="empty">&nbsp;</span><a class="symbol-link" href="#empty">empty</a>();
</h3></div>
<div class="declaration-content"><dl><p>Test if this object doesn't contain any compiled pattern.
</p>

<dt>Example:</dt><dd>
<pre class="d_code">Regex!<span class="d_keyword">char</span> r;
<span class="d_keyword">assert</span>(r.<u>empty</u>);
r = regex(<span class="d_string">""</span>); <span class="d_comment">// Note: "" is a valid regex pattern.
</span>
<span class="d_keyword">assert</span>(!r.<u>empty</u>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property @safe auto <span class="symbol-target" id="namedCaptures">&nbsp;</span><a class="symbol-link" href="#namedCaptures">namedCaptures</a>();
</h3></div>
<div class="declaration-content"><dl><p>A range of all the named captures in the regex.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">import</span> std.range;
<span class="d_keyword">import</span> std.algorithm;

<span class="d_keyword">auto</span> re = regex(<span class="d_string">`(?P&lt;name&gt;\w+) = (?P&lt;var&gt;\d+)`</span>);
<span class="d_keyword">auto</span> nc = re.<u>namedCaptures</u>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isRandomAccessRange!(<span class="d_keyword">typeof</span>(nc)));
<span class="d_keyword">assert</span>(!nc.empty);
<span class="d_keyword">assert</span>(nc.length == 2);
<span class="d_keyword">assert</span>(nc.equal([<span class="d_string">"name"</span>, <span class="d_string">"var"</span>]));
<span class="d_keyword">assert</span>(nc[0] == <span class="d_string">"name"</span>);
<span class="d_keyword">assert</span>(nc[1..$].equal([<span class="d_string">"var"</span>]));
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>NamedGroup[] <span class="symbol-target" id="dict">&nbsp;</span><a class="symbol-link" href="#dict">dict</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint <span class="symbol-target" id="ngroup">&nbsp;</span><a class="symbol-link" href="#ngroup">ngroup</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint <span class="symbol-target" id="maxCounterDepth">&nbsp;</span><a class="symbol-link" href="#maxCounterDepth">maxCounterDepth</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint <span class="symbol-target" id="hotspotTableSize">&nbsp;</span><a class="symbol-link" href="#hotspotTableSize">hotspotTableSize</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint <span class="symbol-target" id="threadCount">&nbsp;</span><a class="symbol-link" href="#threadCount">threadCount</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint <span class="symbol-target" id="flags">&nbsp;</span><a class="symbol-link" href="#flags">flags</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>const(Trie)[] <span class="symbol-target" id="tries">&nbsp;</span><a class="symbol-link" href="#tries">tries</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint[] <span class="symbol-target" id="backrefed">&nbsp;</span><a class="symbol-link" href="#backrefed">backrefed</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>Kickstart!Char <span class="symbol-target" id="kickstart">&nbsp;</span><a class="symbol-link" href="#kickstart">kickstart</a>;
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>uint <span class="symbol-target" id="isBackref">&nbsp;</span><a class="symbol-link" href="#isBackref">isBackref</a>(uint <i>n</i>);
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>void <span class="symbol-target" id="checkIfOneShot">&nbsp;</span><a class="symbol-link" href="#checkIfOneShot">checkIfOneShot</a>();
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>void <span class="symbol-target" id="lightPostprocess">&nbsp;</span><a class="symbol-link" href="#lightPostprocess">lightPostprocess</a>();
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>void <span class="symbol-target" id="validate">&nbsp;</span><a class="symbol-link" href="#validate">validate</a>();
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3>const void <span class="symbol-target" id="print">&nbsp;</span><a class="symbol-link" href="#print">print</a>();
</h3></div>
<div class="declaration-content"><br><br>
</div>
<hr><div class="row-fluid declaration"><h3> this(S)(Parser!S <i>p</i>);
</h3></div>
<div class="declaration-content"><br><br>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="StaticRegex">&nbsp;</span><a class="symbol-link" href="#StaticRegex">StaticRegex</a>(Char);
</h3></div>
<div class="declaration-content"><dl><p>A <span class="inlinecode"><span class="symbol-target" id="StaticRegex">&nbsp;</span><a class="symbol-link" href="#StaticRegex">StaticRegex</a></span> is <span class="inlinecode">Regex</span> object that contains specially
    generated machine code to speed up matching.
    Implicitly convertible to normal <span class="inlinecode">Regex</span>,
    however doing so will result in losing this additional capability.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Captures">&nbsp;</span><a class="symbol-link" href="#Captures">Captures</a>(R, DIndex = size_t) if (isSomeString!R);
</h3></div>
<div class="declaration-content"><dl><p><span class="inlinecode"><span class="symbol-target" id="Captures">&nbsp;</span><a class="symbol-link" href="#Captures">Captures</a></span> object contains submatches captured during a call
    to <span class="inlinecode">match</span> or iteration over <span class="inlinecode">RegexMatch</span> range.
</p>

<p>   First element of range is the whole match.
<br><br>

    Example, showing basic operations on <span class="inlinecode"><span class="symbol-target" id="Captures">&nbsp;</span><a class="symbol-link" href="#Captures">Captures</a></span>:
<pre class="d_code"><span class="d_keyword">import</span> std.regex;
<span class="d_keyword">import</span> std.range;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> m = match(<span class="d_string">"@abc#"</span>, regex(<span class="d_string">`(\w)(\w)(\w)`</span>));
    <span class="d_keyword">auto</span> c = m.captures;
    <span class="d_keyword">assert</span>(c.pre == <span class="d_string">"@"</span>); <span class="d_comment">// Part of input preceeding match
</span>
    <span class="d_keyword">assert</span>(c.post == <span class="d_string">"#"</span>); <span class="d_comment">// Immediately after match
</span>
    <span class="d_keyword">assert</span>(c.hit == c[0] &amp;&amp; c.hit == <span class="d_string">"abc"</span>); <span class="d_comment">// The whole match
</span>
    <span class="d_keyword">assert</span>(c[2] ==<span class="d_string">"b"</span>);
    <span class="d_keyword">assert</span>(c.front == <span class="d_string">"abc"</span>);
    c.popFront();
    <span class="d_keyword">assert</span>(c.front == <span class="d_string">"a"</span>);
    <span class="d_keyword">assert</span>(c.back == <span class="d_string">"c"</span>);
    c.popBack();
    <span class="d_keyword">assert</span>(c.back == <span class="d_string">"b"</span>);
    popFrontN(c, 2);
    <span class="d_keyword">assert</span>(c.empty);
}
</pre>
</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="pre">&nbsp;</span><a class="symbol-link" href="#pre">pre</a>();
</h3></div>
<div class="declaration-content"><dl><p>Slice of input prior to the match.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="post">&nbsp;</span><a class="symbol-link" href="#post">post</a>();
</h3></div>
<div class="declaration-content"><dl><p>Slice of input immediately after the match.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="hit">&nbsp;</span><a class="symbol-link" href="#hit">hit</a>();
</h3></div>
<div class="declaration-content"><dl><p>Slice of matched portion of input.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="front">&nbsp;</span><a class="symbol-link" href="#front">front</a>();
<br>R <span class="symbol-target" id="back">&nbsp;</span><a class="symbol-link" href="#back">back</a>();
<br>void <span class="symbol-target" id="popFront">&nbsp;</span><a class="symbol-link" href="#popFront">popFront</a>();
<br>void <span class="symbol-target" id="popBack">&nbsp;</span><a class="symbol-link" href="#popBack">popBack</a>();
<br>const bool <span class="symbol-target" id="empty">&nbsp;</span><a class="symbol-link" href="#empty">empty</a>();
<br>R <span class="symbol-target" id="opIndex">&nbsp;</span><a class="symbol-link" href="#opIndex">opIndex</a>()(size_t <i>i</i>);
</h3></div>
<div class="declaration-content"><dl><p>Range interface.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="opIndex">&nbsp;</span><a class="symbol-link" href="#opIndex">opIndex</a>(String)(String <i>i</i>) if (isSomeString!String);
</h3></div>
<div class="declaration-content"><dl><p>Lookup named submatch.
</p>

<p><pre class="d_code"><span class="d_keyword">import</span> std.regex;
<span class="d_keyword">import</span> std.range;

<span class="d_keyword">auto</span> m = match(<span class="d_string">"a = 42;"</span>, regex(<span class="d_string">`(?P&lt;var&gt;\w+)\s*=\s*(?P&lt;value&gt;\d+);`</span>));
<span class="d_keyword">auto</span> c = m.captures;
<span class="d_keyword">assert</span>(c[<span class="d_string">"var"</span>] == <span class="d_string">"a"</span>);
<span class="d_keyword">assert</span>(c[<span class="d_string">"value"</span>] == <span class="d_string">"42"</span>);
popFrontN(c, 2);
<span class="d_comment">//named groups are unaffected by range primitives
</span>
<span class="d_keyword">assert</span>(c[<span class="d_string">"var"</span>] ==<span class="d_string">"a"</span>);
<span class="d_keyword">assert</span>(c.front == <span class="d_string">"42"</span>);
</pre>
</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>const size_t <span class="symbol-target" id="length">&nbsp;</span><a class="symbol-link" href="#length">length</a>();
</h3></div>
<div class="declaration-content"><dl><p>Number of matches in this object.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property ref auto <span class="symbol-target" id="captures">&nbsp;</span><a class="symbol-link" href="#captures">captures</a>();
</h3></div>
<div class="declaration-content"><dl><p>A hook for compatibility with original std.regex.</p>

</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="RegexMatch">&nbsp;</span><a class="symbol-link" href="#RegexMatch">RegexMatch</a>(R, alias Engine = ThompsonMatcher) if (isSomeString!R);
</h3></div>
<div class="declaration-content"><dl><p>A regex engine state, as returned by <span class="inlinecode">match</span> family of functions.
</p>

<p>Effectively it's a forward range of Captures!R, produced
    by lazily searching for matches in a given input.
<br><br>

    <span class="inlinecode">alias Engine</span> specifies an engine type to use during matching,
    and is automatically deduced in a call to <span class="inlinecode">match</span>/<span class="inlinecode">bmatch</span>.</p>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="pre">&nbsp;</span><a class="symbol-link" href="#pre">pre</a>();
<br>R <span class="symbol-target" id="post">&nbsp;</span><a class="symbol-link" href="#post">post</a>();
<br>R <span class="symbol-target" id="hit">&nbsp;</span><a class="symbol-link" href="#hit">hit</a>();
</h3></div>
<div class="declaration-content"><dl><p>Shorthands for front.<span class="symbol-target" id="pre">&nbsp;</span><a class="symbol-link" href="#pre">pre</a>, front.post, front.hit.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property auto <span class="symbol-target" id="front">&nbsp;</span><a class="symbol-link" href="#front">front</a>();
<br>void <span class="symbol-target" id="popFront">&nbsp;</span><a class="symbol-link" href="#popFront">popFront</a>();
<br>auto <span class="symbol-target" id="save">&nbsp;</span><a class="symbol-link" href="#save">save</a>();
</h3></div>
<div class="declaration-content"><dl><p>       Functionality for processing subsequent matches of global regexes via range interface:
<pre class="d_code"><span class="d_keyword">import</span> std.regex;
<span class="d_keyword">auto</span> m = match(<span class="d_string">"Hello, world!"</span>, regex(<span class="d_string">`\w+`</span>, <span class="d_string">"g"</span>));
<span class="d_keyword">assert</span>(m.<u>front</u>.hit == <span class="d_string">"Hello"</span>);
m.popFront();
<span class="d_keyword">assert</span>(m.<u>front</u>.hit == <span class="d_string">"world"</span>);
m.popFront();
<span class="d_keyword">assert</span>(m.empty);
</pre>
</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>bool <span class="symbol-target" id="empty">&nbsp;</span><a class="symbol-link" href="#empty">empty</a>();
</h3></div>
<div class="declaration-content"><dl><p>Test if this match object is <span class="symbol-target" id="empty">&nbsp;</span><a class="symbol-link" href="#empty">empty</a>.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>T <span class="symbol-target" id="opCast">&nbsp;</span><a class="symbol-link" href="#opCast">opCast</a>(T : bool)();
</h3></div>
<div class="declaration-content"><dl><p>Same as !(x.empty), provided for its convenience  in conditional statements.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>@property auto <span class="symbol-target" id="captures">&nbsp;</span><a class="symbol-link" href="#captures">captures</a>();
</h3></div>
<div class="declaration-content"><dl><p>Same as .front, provided for compatibility with original std.regex.</p>

</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>auto <span class="symbol-target" id="regex">&nbsp;</span><a class="symbol-link" href="#regex">regex</a>(S)(S <i>pattern</i>, const(char)[] <i>flags</i> = "") if (isSomeString!S);
</h3></div>
<div class="declaration-content"><dl><p>Compile regular expression pattern for the later execution.
</p>

<h3><a id="Returns">Returns, <span class="inlinecode">Regex</span> object that works on inputs having
    the same character width as <span class="inlinecode">pattern</span>.

</a></h3>
<h3><a id="Parameters">Parameters, <table class="table table-condensed table-bordered"><tr><td>S pattern</td>
<td>Regular expression</td>
</tr>
<tr><td>const(char)[] flags</td>
<td>The attributes (g, i, m and x accepted)</td>
</tr>
</table></a></h3>
<h3><a id="Throws">Throws, <span class="inlinecode">RegexException</span> if there were any errors during compilation.</a></h3>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>template <span class="symbol-target" id="ctRegex">&nbsp;</span><a class="symbol-link" href="#ctRegex">ctRegex</a>(alias pattern, alias flags = [])</h3></div>
<div class="declaration-content"><dl><p>Experimental feature.
</p>

<p>Compile regular expression using CTFE
    and generate optimized native machine code for matching it.

</p>
<h3><a id="Returns">Returns, StaticRegex object for faster matching.

</a></h3>
<h3><a id="Parameters">Parameters, <table class="table table-condensed table-bordered"><tr><td>pattern</td>
<td>Regular expression</td>
</tr>
<tr><td>flags</td>
<td>The attributes (g, i, m and x accepted)</td>
</tr>
</table></a></h3>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>auto <span class="symbol-target" id="match">&nbsp;</span><a class="symbol-link" href="#match">match</a>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
<br>auto <span class="symbol-target" id="match">&nbsp;</span><a class="symbol-link" href="#match">match</a>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</h3></div>
<div class="declaration-content"><dl><p>Start matching <span class="inlinecode">input</span> to regex pattern <span class="inlinecode">re</span>,
    using Thompson NFA matching scheme.
</p>

<p>The use of this function is <font color=red>discouraged</font> - use either of
    <a class="symbol-link" href="#matchAll"><span class="inlinecode">matchAll</span></a>
 or <a class="symbol-link" href="#matchFirst"><span class="inlinecode">matchFirst</span></a>
.
<br><br>

    Delegating  the kind of operation
    to "g" flag is soon to be phased out along with the
    ability to choose the exact matching scheme. The choice of
    matching scheme to use depends highly on the pattern kind and
    can done automatically on case by case basis.

</p>
<h3><a id="Returns">Returns, a <span class="inlinecode">RegexMatch</span> object holding engine state after first <span class="symbol-target" id="match">&nbsp;</span><a class="symbol-link" href="#match">match</a>.</a></h3>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>auto <span class="symbol-target" id="matchFirst">&nbsp;</span><a class="symbol-link" href="#matchFirst">matchFirst</a>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
<br>auto <span class="symbol-target" id="matchFirst">&nbsp;</span><a class="symbol-link" href="#matchFirst">matchFirst</a>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</h3></div>
<div class="declaration-content"><dl><p>Find the first (leftmost) slice of the <span class="inlinecode">input</span> that
    matches the pattern <span class="inlinecode">re</span>. This function picks the most suitable
    regular expression engine depending on the pattern properties.
</p>

<p><span class="inlinecode">re</span> parameter can be one of three types:
    <ul>     <li>Plain string, in which case it's compiled to bytecode before matching. </li>
      <li>Regex!char (wchar/dchar) that contains a pattern in the form of
        compiled  bytecode. </li>
      <li>StaticRegex!char (wchar/dchar) that contains a pattern in the form of
        compiled native machine code. </li>
    </ul>

</p>
<h3><a id="Returns">Returns, <a class="symbol-link" href="#Captures"><span class="inlinecode">Captures</span></a>
 containing the extent of a match together with all submatches
    if there was a match, otherwise an empty <a class="symbol-link" href="#Captures"><span class="inlinecode">Captures</span></a>
 object.</a></h3>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>auto <span class="symbol-target" id="matchAll">&nbsp;</span><a class="symbol-link" href="#matchAll">matchAll</a>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
<br>auto <span class="symbol-target" id="matchAll">&nbsp;</span><a class="symbol-link" href="#matchAll">matchAll</a>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</h3></div>
<div class="declaration-content"><dl><p>Initiate a search for all non-overlapping matches to the pattern <span class="inlinecode">re</span>
    in the given <span class="inlinecode">input</span>. The result is a lazy range of matches generated
    as they are encountered in the input going left to right.
</p>

<p>This function picks the most suitable regular expression engine
    depending on the pattern properties.
<br><br>

    <span class="inlinecode">re</span> parameter can be one of three types:
    <ul>     <li>Plain string, in which case it's compiled to bytecode before matching. </li>
      <li>Regex!char (wchar/dchar) that contains a pattern in the form of
        compiled  bytecode. </li>
      <li>StaticRegex!char (wchar/dchar) that contains a pattern in the form of
        compiled native machine code. </li>
    </ul>

</p>
<h3><a id="Returns">Returns, <a class="symbol-link" href="#RegexMatch"><span class="inlinecode">RegexMatch</span></a>
 object that represents matcher state
    after the first match was found or an empty one if not present.</a></h3>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>auto <span class="symbol-target" id="bmatch">&nbsp;</span><a class="symbol-link" href="#bmatch">bmatch</a>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
<br>auto <span class="symbol-target" id="bmatch">&nbsp;</span><a class="symbol-link" href="#bmatch">bmatch</a>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</h3></div>
<div class="declaration-content"><dl><p>Start matching of <span class="inlinecode">input</span> to regex pattern <span class="inlinecode">re</span>,
    using traditional <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=backtracking">backtracking</a>
 matching scheme.
</p>

<p>The use of this function is <font color=red>discouraged</font> - use either of
    <a class="symbol-link" href="#matchAll"><span class="inlinecode">matchAll</span></a>
 or <a class="symbol-link" href="#matchFirst"><span class="inlinecode">matchFirst</span></a>
.
<br><br>

    Delegating  the kind of operation
    to "g" flag is soon to be phased out along with the
    ability to choose the exact matching scheme. The choice of
    matching scheme to use depends highly on the pattern kind and
    can done automatically on case by case basis.

</p>
<h3><a id="Returns">Returns, a <span class="inlinecode">RegexMatch</span> object holding engine
    state after first match.</a></h3>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="replaceFirst">&nbsp;</span><a class="symbol-link" href="#replaceFirst">replaceFirst</a>(R, C, RegEx)(R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>Construct a new string from <span class="inlinecode">input</span> by replacing the first match with
    a string generated from it according to the <span class="inlinecode">format</span> specifier.
</p>

<p>To replace all matches use <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>
.

</p>
<h3><a id="Parameters">Parameters, <table class="table table-condensed table-bordered"><tr><td>R input</td>
<td>string to search</td>
</tr>
<tr><td>RegEx re</td>
<td>compiled regular expression to use</td>
</tr>
<tr><td>const(C)[] format</td>
<td>format string to generate replacements from,
    see <a href="#Replace format string"></a>.</td>
</tr>
</table></a></h3>
<h3><a id="Returns">Returns, A string of the same type with the first match (if any) replaced.
    If no match is found returns the input string itself.

</a></h3>
<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">assert</span>(<u>replaceFirst</u>(<span class="d_string">"noon"</span>, regex(<span class="d_string">"n"</span>), <span class="d_string">"[$&amp;]"</span>) == <span class="d_string">"[n]oon"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="replaceFirst">&nbsp;</span><a class="symbol-link" href="#replaceFirst">replaceFirst</a>(alias fun, R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>This is a general replacement tool that construct a new string by replacing
    matches of pattern <span class="inlinecode">re</span> in the <span class="inlinecode">input</span>. Unlike the other overload
    there is no format string instead captures are passed to
    to a user-defined functor <span class="inlinecode">fun</span> that returns a new string
    to use as replacement.
</p>

<p>This version replaces the first match in <span class="inlinecode">input</span>,
    see <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>
 to replace the all of the matches.

</p>
<h3><a id="Returns">Returns, A new string of the same type as <span class="inlinecode">input</span> with all matches
    replaced by return values of <span class="inlinecode">fun</span>. If no matches found
    returns the <span class="inlinecode">input</span> itself.

</a></h3>
<dt>Example:</dt><dd>
<pre class="d_code">string list = <span class="d_string">"#21 out of 46"</span>;
string newList = <u>replaceFirst</u>!(cap =&gt; to!string(to!<span class="d_keyword">int</span>(cap.hit)+1))
    (list, regex(<span class="d_string">`[0-9]+`</span>));
<span class="d_keyword">assert</span>(newList == <span class="d_string">"#22 out of 46"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>void <span class="symbol-target" id="replaceFirstInto">&nbsp;</span><a class="symbol-link" href="#replaceFirstInto">replaceFirstInto</a>(Sink, R, C, RegEx)(ref Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
<br>void <span class="symbol-target" id="replaceFirstInto">&nbsp;</span><a class="symbol-link" href="#replaceFirstInto">replaceFirstInto</a>(alias fun, Sink, R, RegEx)(Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>A variation on <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
 that instead of allocating a new string
    on each call outputs the result piece-wise to the <span class="inlinecode">sink</span>. In particular
    this enables efficient construction of a final output incrementally.
</p>

<p>Like in <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
 family of functions there is an overload
    for the substitution guided by the <span class="inlinecode">format</span> string
    and the one with the user defined callback.

</p>
<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">import</span> std.array;
string m1 = <span class="d_string">"first message\n"</span>;
string m2 = <span class="d_string">"second message\n"</span>;
<span class="d_keyword">auto</span> result = appender!string();
<u>replaceFirstInto</u>(result, m1, regex(<span class="d_string">`([a-z]+) message`</span>), <span class="d_string">"$1"</span>);
<span class="d_comment">//equivalent of the above with user-defined callback
</span>
<u>replaceFirstInto</u>!(cap=&gt;cap[1])(result, m2, regex(<span class="d_string">`([a-z]+) message`</span>));
<span class="d_keyword">assert</span>(result.data == <span class="d_string">"first\nsecond\n"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="replaceAll">&nbsp;</span><a class="symbol-link" href="#replaceAll">replaceAll</a>(R, C, RegEx)(R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>Construct a new string from <span class="inlinecode">input</span> by replacing all of the
    fragments that match a pattern <span class="inlinecode">re</span> with a string generated
    from the match according to the <span class="inlinecode">format</span> specifier.
</p>

<p>To replace only the first match use <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
.

</p>
<h3><a id="Parameters">Parameters, <table class="table table-condensed table-bordered"><tr><td>R input</td>
<td>string to search</td>
</tr>
<tr><td>RegEx re</td>
<td>compiled regular expression to use</td>
</tr>
<tr><td>const(C)[] format</td>
<td>format string to generate replacements from,
    see <a href="#Replace format string"></a>.</td>
</tr>
</table></a></h3>
<h3><a id="Returns">Returns, A string of the same type as <span class="inlinecode">input</span> with the all
    of the matches (if any) replaced.
    If no match is found returns the input string itself.

</a></h3>
<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_comment">// Comify a number
</span>
<span class="d_keyword">auto</span> com = regex(<span class="d_string">r"(?&lt;=\d)(?=(\d\d\d)+\b)"</span>,<span class="d_string">"g"</span>);
<span class="d_keyword">assert</span>(<u>replaceAll</u>(<span class="d_string">"12000 + 42100 = 54100"</span>, com, <span class="d_string">","</span>) == <span class="d_string">"12,000 + 42,100 = 54,100"</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="replaceAll">&nbsp;</span><a class="symbol-link" href="#replaceAll">replaceAll</a>(alias fun, R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>This is a general replacement tool that construct a new string by replacing
    matches of pattern <span class="inlinecode">re</span> in the <span class="inlinecode">input</span>. Unlike the other overload
    there is no format string instead captures are passed to
    to a user-defined functor <span class="inlinecode">fun</span> that returns a new string
    to use as replacement.
</p>

<p>This version replaces all of the matches found in <span class="inlinecode">input</span>,
    see <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
 to replace the first match only.

</p>
<h3><a id="Returns">Returns, A new string of the same type as <span class="inlinecode">input</span> with all matches
    replaced by return values of <span class="inlinecode">fun</span>. If no matches found
    returns the <span class="inlinecode">input</span> itself.

</a></h3>
<h3><a id="Parameters">Parameters, <table class="table table-condensed table-bordered"><tr><td>R input</td>
<td>string to search</td>
</tr>
<tr><td>RegEx re</td>
<td>compiled regular expression</td>
</tr>
<tr><td>fun</td>
<td>delegate to use</td>
</tr>
</table></a></h3>
<dt>Example:</dt><dd>
    Capitalize the letters 'a' and 'r':
<pre class="d_code">string baz(Captures!(string) m)
{
    <span class="d_keyword">return</span> std.string.toUpper(m.hit);
}
<span class="d_keyword">auto</span> s = <u>replaceAll</u>!(baz)(<span class="d_string">"Strap a rocket engine on a chicken."</span>,
        regex(<span class="d_string">"[ar]"</span>));
<span class="d_keyword">assert</span>(s == <span class="d_string">"StRAp A Rocket engine on A chicken."</span>);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>void <span class="symbol-target" id="replaceAllInto">&nbsp;</span><a class="symbol-link" href="#replaceAllInto">replaceAllInto</a>(Sink, R, C, RegEx)(Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
<br>void <span class="symbol-target" id="replaceAllInto">&nbsp;</span><a class="symbol-link" href="#replaceAllInto">replaceAllInto</a>(alias fun, Sink, R, RegEx)(Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>A variation on <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>
 that instead of allocating a new string
    on each call outputs the result piece-wise to the <span class="inlinecode">sink</span>. In particular
    this enables efficient construction of a final output incrementally.
</p>

<p>As with <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>
 there are 2 overloads - one with a format string,
    the other one with a user defined functor.

</p>
<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_comment">//swap all 3 letter words and bring it back
</span>
string text = <span class="d_string">"How are you doing?"</span>;
<span class="d_keyword">auto</span> sink = appender!(<span class="d_keyword">char</span>[])();
<u>replaceAllInto</u>!(cap =&gt; retro(cap[0]))(sink, text, regex(<span class="d_string">`\b\w{3}\b`</span>));
<span class="d_keyword">auto</span> swapped = sink.data.dup; <span class="d_comment">// make a copy explicitly
</span>
<span class="d_keyword">assert</span>(swapped == <span class="d_string">"woH era uoy doing?"</span>);
sink.clear();
<u>replaceAllInto</u>!(cap =&gt; retro(cap[0]))(sink, swapped, regex(<span class="d_string">`\b\w{3}\b`</span>));
<span class="d_keyword">assert</span>(sink.data == text);
</pre>
</dd>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>R <span class="symbol-target" id="replace">&nbsp;</span><a class="symbol-link" href="#replace">replace</a>(alias scheme = match, R, C, RegEx)(R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
<br>R <span class="symbol-target" id="replace">&nbsp;</span><a class="symbol-link" href="#replace">replace</a>(alias fun, R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</h3></div>
<div class="declaration-content"><dl><p>Old API for replacement, operation depends on flags of pattern <span class="inlinecode">re</span>.
    With "g" flag it performs the equivalent of <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>
 otherwise it
    works the same as <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
.
</p>

<p>The use of this function is <font color=red>discouraged</font>, please use <a class="symbol-link" href="#replaceAll"><span class="inlinecode">replaceAll</span></a>

    or <a class="symbol-link" href="#replaceFirst"><span class="inlinecode">replaceFirst</span></a>
 explicitly.</p>
</dl>
</div>
<hr><div class="row-fluid declaration"><h3>struct <span class="symbol-target" id="Splitter">&nbsp;</span><a class="symbol-link" href="#Splitter">Splitter</a>(Range, alias RegEx = Regex) if (isSomeString!Range &amp;&amp; isRegexFor!(RegEx, Range));
</h3></div>
<div class="declaration-content"><dl><p>Range that splits a string using a regular expression as a
separator.
</p>

<dt>Example:</dt><dd>
<pre class="d_code"><span class="d_keyword">auto</span> s1 = <span class="d_string">", abc, de,  fg, hi, "</span>;
<span class="d_keyword">assert</span>(equal(splitter(s1, regex(<span class="d_string">", *"</span>)),
    [<span class="d_string">""</span>, <span class="d_string">"abc"</span>, <span class="d_string">"de"</span>, <span class="d_string">"fg"</span>, <span class="d_string">"hi"</span>, <span class="d_string">""</span>]));
</pre>
</dd>
</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3>Range <span class="symbol-target" id="front">&nbsp;</span><a class="symbol-link" href="#front">front</a>();
<br>bool <span class="symbol-target" id="empty">&nbsp;</span><a class="symbol-link" href="#empty">empty</a>();
<br>void <span class="symbol-target" id="popFront">&nbsp;</span><a class="symbol-link" href="#popFront">popFront</a>();
<br>@property auto <span class="symbol-target" id="save">&nbsp;</span><a class="symbol-link" href="#save">save</a>();
</h3></div>
<div class="declaration-content"><dl><p>Forward range primitives.</p>

</dl>
</div>
</div>
</div>
<hr><div class="row-fluid declaration"><h3>Splitter!(Range, RegEx) <span class="symbol-target" id="splitter">&nbsp;</span><a class="symbol-link" href="#splitter">splitter</a>(Range, RegEx)(Range <i>r</i>, RegEx <i>pat</i>) if (is(BasicElementOf!Range : dchar) &amp;&amp; isRegexFor!(RegEx, Range));
</h3></div>
<div class="declaration-content"><dl><p>A helper function, creates a <span class="inlinecode">Splitter</span> on range <span class="inlinecode">r</span> separated by regex <span class="inlinecode">pat</span>.
    Captured subexpressions have no effect on the resulting range.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>String[] <span class="symbol-target" id="split">&nbsp;</span><a class="symbol-link" href="#split">split</a>(String, RegEx)(String <i>input</i>, RegEx <i>rx</i>) if (isSomeString!String &amp;&amp; isRegexFor!(RegEx, String));
</h3></div>
<div class="declaration-content"><dl><p>An eager version of <span class="inlinecode">splitter</span> that creates an array with splitted slices of <span class="inlinecode">input</span>.</p>

</dl>
</div>
<hr><div class="row-fluid declaration"><h3>class <span class="symbol-target" id="RegexException">&nbsp;</span><a class="symbol-link" href="#RegexException">RegexException</a>: object.Exception;
</h3></div>
<div class="declaration-content"><dl><p>Exception object thrown in case of errors during regex compilation.</p>

</dl>
<div class="offset1 member-list"><hr><div class="row-fluid declaration"><h3> this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</h3></div>
<div class="declaration-content"><br><br>
</div>
</div>
</div>


				</div>
				
				<hr>
				
				<footer class="pull-left">
					<p>Page generated with <a href="https://github.com/JakobOvrum/bootDoc">bootDoc</a>.</p>
				</footer>
				
				<footer class="pull-right">
					<p>&copy; Copyright Dmitry Olshansky, 2011-

</p>
				</footer>
			</div>
		</div>
	</div><!--/.fluid-container-->

	<!-- Bootstrap javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="bootDoc/assets/js/jquery.min.js"></script>
	<script src="bootDoc/assets/js/bootstrap.min.js"></script>
	
	<!-- bootDoc javascript
	================================================== -->
	<script src="bootDoc/bootdoc.js"></script>
	
	</body>
</html>

